;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package spyglass.streamline.alpha.ast
;;;----------------------------------------------------------------------------------
(ns spyglass.streamline.alpha.ast
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [sf.substreams.v1 :as sf.substreams.v1]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->ContractFunctionParameter)
(declare ecis->ContractFunctionParameter)
(declare new-ContractFunctionParameter)
(declare cis->FieldAccess)
(declare ecis->FieldAccess)
(declare new-FieldAccess)
(declare cis->StructLiteralField)
(declare ecis->StructLiteralField)
(declare new-StructLiteralField)
(declare cis->BinaryOp)
(declare ecis->BinaryOp)
(declare new-BinaryOp)
(declare cis->Expression)
(declare ecis->Expression)
(declare new-Expression)
(declare cis->ContractAbi)
(declare ecis->ContractAbi)
(declare new-ContractAbi)
(declare cis->StructDef)
(declare ecis->StructDef)
(declare new-StructDef)
(declare cis->FileMeta)
(declare ecis->FileMeta)
(declare new-FileMeta)
(declare cis->FunctionAbi)
(declare ecis->FunctionAbi)
(declare new-FunctionAbi)
(declare cis->ContractInstance)
(declare ecis->ContractInstance)
(declare new-ContractInstance)
(declare cis->Lambda)
(declare ecis->Lambda)
(declare new-Lambda)
(declare cis->StructLiteral)
(declare ecis->StructLiteral)
(declare new-StructLiteral)
(declare cis->EventAbi)
(declare ecis->EventAbi)
(declare new-EventAbi)
(declare cis->EventInput)
(declare ecis->EventInput)
(declare new-EventInput)
(declare cis->StreamlineFile)
(declare ecis->StreamlineFile)
(declare new-StreamlineFile)
(declare cis->FunctionCall)
(declare ecis->FunctionCall)
(declare new-FunctionCall)
(declare cis->Conversion)
(declare ecis->Conversion)
(declare new-Conversion)
(declare cis->Function)
(declare ecis->Function)
(declare new-Function)
(declare cis->Hof)
(declare ecis->Hof)
(declare new-Hof)
(declare cis->FunctionInput)
(declare ecis->FunctionInput)
(declare new-FunctionInput)
(declare cis->ModuleDef)
(declare ecis->ModuleDef)
(declare new-ModuleDef)
(declare cis->ModuleSignature)
(declare ecis->ModuleSignature)
(declare new-ModuleSignature)
(declare cis->StructField)
(declare ecis->StructField)
(declare new-StructField)
(declare cis->Literal)
(declare ecis->Literal)
(declare new-Literal)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; StreamlineKind
;-----------------------------------------------------------------------------
(def StreamlineKind-default :substream)

(def StreamlineKind-val2label {
  0 :substream
  1 :sink})

(def StreamlineKind-label2val (set/map-invert StreamlineKind-val2label))

(defn cis->StreamlineKind [is]
  (let [val (serdes.core/cis->Enum is)]
    (get StreamlineKind-val2label val val)))

(defn- get-StreamlineKind [value]
  {:pre [(or (int? value) (contains? StreamlineKind-label2val value))]}
  (get StreamlineKind-label2val value value))

(defn write-StreamlineKind
  ([tag value os] (write-StreamlineKind tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-StreamlineKind value) os)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Expression-expression's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Expression-expression [origkeyval]
  (cond
     (get-in origkeyval [:expression :literal]) (update-in origkeyval [:expression :literal] new-Literal)
     (get-in origkeyval [:expression :identifier]) origkeyval
     (get-in origkeyval [:expression :function-call]) (update-in origkeyval [:expression :function-call] new-FunctionCall)
     (get-in origkeyval [:expression :binary-op]) (update-in origkeyval [:expression :binary-op] new-BinaryOp)
     (get-in origkeyval [:expression :field-access]) (update-in origkeyval [:expression :field-access] new-FieldAccess)
     :default origkeyval))

(defn write-Expression-expression [expression os]
  (let [field (first expression)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :literal (serdes.core/write-embedded 1 v os)
         :identifier (serdes.core/write-String 2  {:optimize false} v os)
         :function-call (serdes.core/write-embedded 3 v os)
         :binary-op (serdes.core/write-embedded 4 v os)
         :field-access (serdes.core/write-embedded 5 v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Function-function's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Function-function [origkeyval]
  (cond
     (get-in origkeyval [:function :lambda]) (update-in origkeyval [:function :lambda] new-Lambda)
     (get-in origkeyval [:function :hof]) (update-in origkeyval [:function :hof] new-Hof)
     :default origkeyval))

(defn write-Function-function [function os]
  (let [field (first function)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :lambda (serdes.core/write-embedded 1 v os)
         :hof (serdes.core/write-embedded 2 v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Literal-literal's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Literal-literal [origkeyval]
  (cond
     (get-in origkeyval [:literal :int]) origkeyval
     (get-in origkeyval [:literal :str]) origkeyval
     (get-in origkeyval [:literal :boolean]) origkeyval
     (get-in origkeyval [:literal :struct]) (update-in origkeyval [:literal :struct] new-StructLiteral)
     :default origkeyval))

(defn write-Literal-literal [literal os]
  (let [field (first literal)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :int (serdes.core/write-Int64 1  {:optimize false} v os)
         :str (serdes.core/write-String 2  {:optimize false} v os)
         :boolean (serdes.core/write-Bool 3  {:optimize false} v os)
         :struct (serdes.core/write-embedded 4 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ContractFunctionParameter
;-----------------------------------------------------------------------------
(defrecord ContractFunctionParameter-record [name type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-String 2  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.ContractFunctionParameter"))

(s/def :spyglass.streamline.alpha.ast.ContractFunctionParameter/name string?)
(s/def :spyglass.streamline.alpha.ast.ContractFunctionParameter/type string?)
(s/def ::ContractFunctionParameter-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.ContractFunctionParameter/name :spyglass.streamline.alpha.ast.ContractFunctionParameter/type ]))
(def ContractFunctionParameter-defaults {:name "" :type "" })

(defn cis->ContractFunctionParameter
  "CodedInputStream to ContractFunctionParameter"
  [is]
  (->> (tag-map ContractFunctionParameter-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ContractFunctionParameter-record)))

(defn ecis->ContractFunctionParameter
  "Embedded CodedInputStream to ContractFunctionParameter"
  [is]
  (serdes.core/cis->embedded cis->ContractFunctionParameter is))

(defn new-ContractFunctionParameter
  "Creates a new instance from a map, similar to map->ContractFunctionParameter except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ContractFunctionParameter-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ContractFunctionParameter-spec init))))]}
  (-> (merge ContractFunctionParameter-defaults init)
      (map->ContractFunctionParameter-record)))

(defn pb->ContractFunctionParameter
  "Protobuf to ContractFunctionParameter"
  [input]
  (cis->ContractFunctionParameter (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ContractFunctionParameter-meta {:type "spyglass.streamline.alpha.ast.ContractFunctionParameter" :decoder pb->ContractFunctionParameter})

;-----------------------------------------------------------------------------
; FieldAccess
;-----------------------------------------------------------------------------
(defrecord FieldAccess-record [target field]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:target this) os)
    (serdes.core/write-String 2  {:optimize true} (:field this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.FieldAccess"))

(s/def :spyglass.streamline.alpha.ast.FieldAccess/field string?)
(s/def ::FieldAccess-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.FieldAccess/field ]))
(def FieldAccess-defaults {:field "" })

(defn cis->FieldAccess
  "CodedInputStream to FieldAccess"
  [is]
  (->> (tag-map FieldAccess-defaults
         (fn [tag index]
             (case index
               1 [:target (ecis->Expression is)]
               2 [:field (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FieldAccess-record)))

(defn ecis->FieldAccess
  "Embedded CodedInputStream to FieldAccess"
  [is]
  (serdes.core/cis->embedded cis->FieldAccess is))

(defn new-FieldAccess
  "Creates a new instance from a map, similar to map->FieldAccess except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FieldAccess-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FieldAccess-spec init))))]}
  (-> (merge FieldAccess-defaults init)
      (cond-> (some? (get init :target)) (update :target new-Expression))
      (map->FieldAccess-record)))

(defn pb->FieldAccess
  "Protobuf to FieldAccess"
  [input]
  (cis->FieldAccess (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FieldAccess-meta {:type "spyglass.streamline.alpha.ast.FieldAccess" :decoder pb->FieldAccess})

;-----------------------------------------------------------------------------
; StructLiteralField
;-----------------------------------------------------------------------------
(defrecord StructLiteralField-record [name value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-embedded 2 (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.StructLiteralField"))

(s/def :spyglass.streamline.alpha.ast.StructLiteralField/name string?)

(s/def ::StructLiteralField-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.StructLiteralField/name ]))
(def StructLiteralField-defaults {:name "" })

(defn cis->StructLiteralField
  "CodedInputStream to StructLiteralField"
  [is]
  (->> (tag-map StructLiteralField-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:value (ecis->Expression is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StructLiteralField-record)))

(defn ecis->StructLiteralField
  "Embedded CodedInputStream to StructLiteralField"
  [is]
  (serdes.core/cis->embedded cis->StructLiteralField is))

(defn new-StructLiteralField
  "Creates a new instance from a map, similar to map->StructLiteralField except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StructLiteralField-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StructLiteralField-spec init))))]}
  (-> (merge StructLiteralField-defaults init)
      (cond-> (some? (get init :value)) (update :value new-Expression))
      (map->StructLiteralField-record)))

(defn pb->StructLiteralField
  "Protobuf to StructLiteralField"
  [input]
  (cis->StructLiteralField (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StructLiteralField-meta {:type "spyglass.streamline.alpha.ast.StructLiteralField" :decoder pb->StructLiteralField})

;-----------------------------------------------------------------------------
; BinaryOp
;-----------------------------------------------------------------------------
(defrecord BinaryOp-record [op]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:op this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.BinaryOp"))

(s/def :spyglass.streamline.alpha.ast.BinaryOp/op string?)
(s/def ::BinaryOp-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.BinaryOp/op ]))
(def BinaryOp-defaults {:op "" })

(defn cis->BinaryOp
  "CodedInputStream to BinaryOp"
  [is]
  (->> (tag-map BinaryOp-defaults
         (fn [tag index]
             (case index
               1 [:op (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BinaryOp-record)))

(defn ecis->BinaryOp
  "Embedded CodedInputStream to BinaryOp"
  [is]
  (serdes.core/cis->embedded cis->BinaryOp is))

(defn new-BinaryOp
  "Creates a new instance from a map, similar to map->BinaryOp except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BinaryOp-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BinaryOp-spec init))))]}
  (-> (merge BinaryOp-defaults init)
      (map->BinaryOp-record)))

(defn pb->BinaryOp
  "Protobuf to BinaryOp"
  [input]
  (cis->BinaryOp (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BinaryOp-meta {:type "spyglass.streamline.alpha.ast.BinaryOp" :decoder pb->BinaryOp})

;-----------------------------------------------------------------------------
; Expression
;-----------------------------------------------------------------------------
(defrecord Expression-record [expression]
  pb/Writer
  (serialize [this os]
    (write-Expression-expression  (:expression this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.Expression"))

(s/def ::Expression-spec (s/keys :opt-un []))
(def Expression-defaults {})

(defn cis->Expression
  "CodedInputStream to Expression"
  [is]
  (->> (tag-map Expression-defaults
         (fn [tag index]
             (case index
               1 [:expression {:literal (ecis->Literal is)}]
               2 [:expression {:identifier (serdes.core/cis->String is)}]
               3 [:expression {:function-call (ecis->FunctionCall is)}]
               4 [:expression {:binary-op (ecis->BinaryOp is)}]
               5 [:expression {:field-access (ecis->FieldAccess is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Expression-record)))

(defn ecis->Expression
  "Embedded CodedInputStream to Expression"
  [is]
  (serdes.core/cis->embedded cis->Expression is))

(defn new-Expression
  "Creates a new instance from a map, similar to map->Expression except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Expression-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Expression-spec init))))]}
  (-> (merge Expression-defaults init)
      (convert-Expression-expression)
      (map->Expression-record)))

(defn pb->Expression
  "Protobuf to Expression"
  [input]
  (cis->Expression (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Expression-meta {:type "spyglass.streamline.alpha.ast.Expression" :decoder pb->Expression})

;-----------------------------------------------------------------------------
; ContractAbi
;-----------------------------------------------------------------------------
(defrecord ContractAbi-record [name abi-json events functions]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-String 2  {:optimize true} (:abi-json this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:events this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:functions this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.ContractAbi"))

(s/def :spyglass.streamline.alpha.ast.ContractAbi/name string?)
(s/def :spyglass.streamline.alpha.ast.ContractAbi/abi-json string?)


(s/def ::ContractAbi-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.ContractAbi/name :spyglass.streamline.alpha.ast.ContractAbi/abi-json ]))
(def ContractAbi-defaults {:name "" :abi-json "" :events [] :functions [] })

(defn cis->ContractAbi
  "CodedInputStream to ContractAbi"
  [is]
  (->> (tag-map ContractAbi-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:abi-json (serdes.core/cis->String is)]
               3 [:events (serdes.complex/cis->repeated ecis->EventAbi is)]
               4 [:functions (serdes.complex/cis->repeated ecis->FunctionAbi is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ContractAbi-record)))

(defn ecis->ContractAbi
  "Embedded CodedInputStream to ContractAbi"
  [is]
  (serdes.core/cis->embedded cis->ContractAbi is))

(defn new-ContractAbi
  "Creates a new instance from a map, similar to map->ContractAbi except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ContractAbi-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ContractAbi-spec init))))]}
  (-> (merge ContractAbi-defaults init)
      (cond-> (some? (get init :events)) (update :events #(map new-EventAbi %)))
      (cond-> (some? (get init :functions)) (update :functions #(map new-FunctionAbi %)))
      (map->ContractAbi-record)))

(defn pb->ContractAbi
  "Protobuf to ContractAbi"
  [input]
  (cis->ContractAbi (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ContractAbi-meta {:type "spyglass.streamline.alpha.ast.ContractAbi" :decoder pb->ContractAbi})

;-----------------------------------------------------------------------------
; StructDef
;-----------------------------------------------------------------------------
(defrecord StructDef-record [name fields]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:fields this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.StructDef"))

(s/def :spyglass.streamline.alpha.ast.StructDef/name string?)

(s/def ::StructDef-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.StructDef/name ]))
(def StructDef-defaults {:name "" :fields [] })

(defn cis->StructDef
  "CodedInputStream to StructDef"
  [is]
  (->> (tag-map StructDef-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:fields (serdes.complex/cis->repeated ecis->StructField is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StructDef-record)))

(defn ecis->StructDef
  "Embedded CodedInputStream to StructDef"
  [is]
  (serdes.core/cis->embedded cis->StructDef is))

(defn new-StructDef
  "Creates a new instance from a map, similar to map->StructDef except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StructDef-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StructDef-spec init))))]}
  (-> (merge StructDef-defaults init)
      (cond-> (some? (get init :fields)) (update :fields #(map new-StructField %)))
      (map->StructDef-record)))

(defn pb->StructDef
  "Protobuf to StructDef"
  [input]
  (cis->StructDef (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StructDef-meta {:type "spyglass.streamline.alpha.ast.StructDef" :decoder pb->StructDef})

;-----------------------------------------------------------------------------
; FileMeta
;-----------------------------------------------------------------------------
(defrecord FileMeta-record [name kind]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (write-StreamlineKind 2  {:optimize true} (:kind this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.FileMeta"))

(s/def :spyglass.streamline.alpha.ast.FileMeta/name string?)
(s/def :spyglass.streamline.alpha.ast.FileMeta/kind (s/or :keyword keyword? :int int?))
(s/def ::FileMeta-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.FileMeta/name :spyglass.streamline.alpha.ast.FileMeta/kind ]))
(def FileMeta-defaults {:name "" :kind StreamlineKind-default })

(defn cis->FileMeta
  "CodedInputStream to FileMeta"
  [is]
  (->> (tag-map FileMeta-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:kind (cis->StreamlineKind is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FileMeta-record)))

(defn ecis->FileMeta
  "Embedded CodedInputStream to FileMeta"
  [is]
  (serdes.core/cis->embedded cis->FileMeta is))

(defn new-FileMeta
  "Creates a new instance from a map, similar to map->FileMeta except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FileMeta-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FileMeta-spec init))))]}
  (-> (merge FileMeta-defaults init)
      (map->FileMeta-record)))

(defn pb->FileMeta
  "Protobuf to FileMeta"
  [input]
  (cis->FileMeta (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FileMeta-meta {:type "spyglass.streamline.alpha.ast.FileMeta" :decoder pb->FileMeta})

;-----------------------------------------------------------------------------
; FunctionAbi
;-----------------------------------------------------------------------------
(defrecord FunctionAbi-record [type name inputs outputs state-mutability]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os)
    (serdes.core/write-String 2  {:optimize true} (:name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:inputs this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:outputs this) os)
    (serdes.core/write-String 5  {:optimize true} (:state-mutability this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.FunctionAbi"))

(s/def :spyglass.streamline.alpha.ast.FunctionAbi/type string?)
(s/def :spyglass.streamline.alpha.ast.FunctionAbi/name string?)


(s/def :spyglass.streamline.alpha.ast.FunctionAbi/state-mutability string?)
(s/def ::FunctionAbi-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.FunctionAbi/type :spyglass.streamline.alpha.ast.FunctionAbi/name :spyglass.streamline.alpha.ast.FunctionAbi/state-mutability ]))
(def FunctionAbi-defaults {:type "" :name "" :inputs [] :outputs [] :state-mutability "" })

(defn cis->FunctionAbi
  "CodedInputStream to FunctionAbi"
  [is]
  (->> (tag-map FunctionAbi-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]
               2 [:name (serdes.core/cis->String is)]
               3 [:inputs (serdes.complex/cis->repeated ecis->FunctionInput is)]
               4 [:outputs (serdes.complex/cis->repeated ecis->FunctionInput is)]
               5 [:state-mutability (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FunctionAbi-record)))

(defn ecis->FunctionAbi
  "Embedded CodedInputStream to FunctionAbi"
  [is]
  (serdes.core/cis->embedded cis->FunctionAbi is))

(defn new-FunctionAbi
  "Creates a new instance from a map, similar to map->FunctionAbi except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FunctionAbi-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FunctionAbi-spec init))))]}
  (-> (merge FunctionAbi-defaults init)
      (cond-> (some? (get init :inputs)) (update :inputs #(map new-FunctionInput %)))
      (cond-> (some? (get init :outputs)) (update :outputs #(map new-FunctionInput %)))
      (map->FunctionAbi-record)))

(defn pb->FunctionAbi
  "Protobuf to FunctionAbi"
  [input]
  (cis->FunctionAbi (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FunctionAbi-meta {:type "spyglass.streamline.alpha.ast.FunctionAbi" :decoder pb->FunctionAbi})

;-----------------------------------------------------------------------------
; ContractInstance
;-----------------------------------------------------------------------------
(defrecord ContractInstance-record [address contract-interface instance-name]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:address this) os)
    (serdes.core/write-String 2  {:optimize true} (:contract-interface this) os)
    (serdes.core/write-String 3  {:optimize true} (:instance-name this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.ContractInstance"))

(s/def :spyglass.streamline.alpha.ast.ContractInstance/address string?)
(s/def :spyglass.streamline.alpha.ast.ContractInstance/contract-interface string?)
(s/def :spyglass.streamline.alpha.ast.ContractInstance/instance-name string?)
(s/def ::ContractInstance-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.ContractInstance/address :spyglass.streamline.alpha.ast.ContractInstance/contract-interface :spyglass.streamline.alpha.ast.ContractInstance/instance-name ]))
(def ContractInstance-defaults {:address "" :contract-interface "" :instance-name "" })

(defn cis->ContractInstance
  "CodedInputStream to ContractInstance"
  [is]
  (->> (tag-map ContractInstance-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->String is)]
               2 [:contract-interface (serdes.core/cis->String is)]
               3 [:instance-name (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ContractInstance-record)))

(defn ecis->ContractInstance
  "Embedded CodedInputStream to ContractInstance"
  [is]
  (serdes.core/cis->embedded cis->ContractInstance is))

(defn new-ContractInstance
  "Creates a new instance from a map, similar to map->ContractInstance except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ContractInstance-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ContractInstance-spec init))))]}
  (-> (merge ContractInstance-defaults init)
      (map->ContractInstance-record)))

(defn pb->ContractInstance
  "Protobuf to ContractInstance"
  [input]
  (cis->ContractInstance (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ContractInstance-meta {:type "spyglass.streamline.alpha.ast.ContractInstance" :decoder pb->ContractInstance})

;-----------------------------------------------------------------------------
; Lambda
;-----------------------------------------------------------------------------
(defrecord Lambda-record [inputs body]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-String 1 (:inputs this) os)
    (serdes.core/write-embedded 2 (:body this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.Lambda"))

(s/def :spyglass.streamline.alpha.ast.Lambda/inputs (s/every string?))

(s/def ::Lambda-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.Lambda/inputs ]))
(def Lambda-defaults {:inputs [] })

(defn cis->Lambda
  "CodedInputStream to Lambda"
  [is]
  (->> (tag-map Lambda-defaults
         (fn [tag index]
             (case index
               1 [:inputs (serdes.complex/cis->repeated serdes.core/cis->String is)]
               2 [:body (ecis->Expression is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Lambda-record)))

(defn ecis->Lambda
  "Embedded CodedInputStream to Lambda"
  [is]
  (serdes.core/cis->embedded cis->Lambda is))

(defn new-Lambda
  "Creates a new instance from a map, similar to map->Lambda except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Lambda-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Lambda-spec init))))]}
  (-> (merge Lambda-defaults init)
      (cond-> (some? (get init :body)) (update :body new-Expression))
      (map->Lambda-record)))

(defn pb->Lambda
  "Protobuf to Lambda"
  [input]
  (cis->Lambda (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Lambda-meta {:type "spyglass.streamline.alpha.ast.Lambda" :decoder pb->Lambda})

;-----------------------------------------------------------------------------
; StructLiteral
;-----------------------------------------------------------------------------
(defrecord StructLiteral-record [name fields]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:fields this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.StructLiteral"))

(s/def :spyglass.streamline.alpha.ast.StructLiteral/name string?)

(s/def ::StructLiteral-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.StructLiteral/name ]))
(def StructLiteral-defaults {:name "" :fields [] })

(defn cis->StructLiteral
  "CodedInputStream to StructLiteral"
  [is]
  (->> (tag-map StructLiteral-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:fields (serdes.complex/cis->repeated ecis->StructLiteralField is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StructLiteral-record)))

(defn ecis->StructLiteral
  "Embedded CodedInputStream to StructLiteral"
  [is]
  (serdes.core/cis->embedded cis->StructLiteral is))

(defn new-StructLiteral
  "Creates a new instance from a map, similar to map->StructLiteral except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StructLiteral-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StructLiteral-spec init))))]}
  (-> (merge StructLiteral-defaults init)
      (cond-> (some? (get init :fields)) (update :fields #(map new-StructLiteralField %)))
      (map->StructLiteral-record)))

(defn pb->StructLiteral
  "Protobuf to StructLiteral"
  [input]
  (cis->StructLiteral (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StructLiteral-meta {:type "spyglass.streamline.alpha.ast.StructLiteral" :decoder pb->StructLiteral})

;-----------------------------------------------------------------------------
; EventAbi
;-----------------------------------------------------------------------------
(defrecord EventAbi-record [type name inputs]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os)
    (serdes.core/write-String 2  {:optimize true} (:name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:inputs this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.EventAbi"))

(s/def :spyglass.streamline.alpha.ast.EventAbi/type string?)
(s/def :spyglass.streamline.alpha.ast.EventAbi/name string?)

(s/def ::EventAbi-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.EventAbi/type :spyglass.streamline.alpha.ast.EventAbi/name ]))
(def EventAbi-defaults {:type "" :name "" :inputs [] })

(defn cis->EventAbi
  "CodedInputStream to EventAbi"
  [is]
  (->> (tag-map EventAbi-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]
               2 [:name (serdes.core/cis->String is)]
               3 [:inputs (serdes.complex/cis->repeated ecis->EventInput is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->EventAbi-record)))

(defn ecis->EventAbi
  "Embedded CodedInputStream to EventAbi"
  [is]
  (serdes.core/cis->embedded cis->EventAbi is))

(defn new-EventAbi
  "Creates a new instance from a map, similar to map->EventAbi except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EventAbi-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EventAbi-spec init))))]}
  (-> (merge EventAbi-defaults init)
      (cond-> (some? (get init :inputs)) (update :inputs #(map new-EventInput %)))
      (map->EventAbi-record)))

(defn pb->EventAbi
  "Protobuf to EventAbi"
  [input]
  (cis->EventAbi (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EventAbi-meta {:type "spyglass.streamline.alpha.ast.EventAbi" :decoder pb->EventAbi})

;-----------------------------------------------------------------------------
; EventInput
;-----------------------------------------------------------------------------
(defrecord EventInput-record [type name indexed]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os)
    (serdes.core/write-String 2  {:optimize true} (:name this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:indexed this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.EventInput"))

(s/def :spyglass.streamline.alpha.ast.EventInput/type string?)
(s/def :spyglass.streamline.alpha.ast.EventInput/name string?)
(s/def :spyglass.streamline.alpha.ast.EventInput/indexed boolean?)
(s/def ::EventInput-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.EventInput/type :spyglass.streamline.alpha.ast.EventInput/name :spyglass.streamline.alpha.ast.EventInput/indexed ]))
(def EventInput-defaults {:type "" :name "" :indexed false })

(defn cis->EventInput
  "CodedInputStream to EventInput"
  [is]
  (->> (tag-map EventInput-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]
               2 [:name (serdes.core/cis->String is)]
               3 [:indexed (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->EventInput-record)))

(defn ecis->EventInput
  "Embedded CodedInputStream to EventInput"
  [is]
  (serdes.core/cis->embedded cis->EventInput is))

(defn new-EventInput
  "Creates a new instance from a map, similar to map->EventInput except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EventInput-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EventInput-spec init))))]}
  (-> (merge EventInput-defaults init)
      (map->EventInput-record)))

(defn pb->EventInput
  "Protobuf to EventInput"
  [input]
  (cis->EventInput (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EventInput-meta {:type "spyglass.streamline.alpha.ast.EventInput" :decoder pb->EventInput})

;-----------------------------------------------------------------------------
; StreamlineFile
;-----------------------------------------------------------------------------
(defrecord StreamlineFile-record [modules conversions types abi-json array-types protobufs contracts meta instances]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:modules this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 7 (:conversions this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:types this) os)
    (serdes.complex/write-repeated serdes.core/write-String 4 (:abi-json this) os)
    (serdes.complex/write-repeated serdes.core/write-String 8 (:array-types this) os)
    (serdes.complex/write-repeated serdes.core/write-String 5 (:protobufs this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:contracts this) os)
    (serdes.core/write-embedded 9 (:meta this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 6 (:instances this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.StreamlineFile"))

(s/def :spyglass.streamline.alpha.ast.StreamlineFile/abi-json (s/every string?))
(s/def :spyglass.streamline.alpha.ast.StreamlineFile/array-types (s/every string?))
(s/def :spyglass.streamline.alpha.ast.StreamlineFile/protobufs (s/every string?))



(s/def ::StreamlineFile-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.StreamlineFile/abi-json :spyglass.streamline.alpha.ast.StreamlineFile/array-types :spyglass.streamline.alpha.ast.StreamlineFile/protobufs ]))
(def StreamlineFile-defaults {:modules [] :conversions [] :types [] :abi-json [] :array-types [] :protobufs [] :contracts [] :instances [] })

(defn cis->StreamlineFile
  "CodedInputStream to StreamlineFile"
  [is]
  (->> (tag-map StreamlineFile-defaults
         (fn [tag index]
             (case index
               3 [:modules (serdes.complex/cis->repeated ecis->ModuleDef is)]
               7 [:conversions (serdes.complex/cis->repeated ecis->Conversion is)]
               1 [:types (serdes.complex/cis->repeated ecis->StructDef is)]
               4 [:abi-json (serdes.complex/cis->repeated serdes.core/cis->String is)]
               8 [:array-types (serdes.complex/cis->repeated serdes.core/cis->String is)]
               5 [:protobufs (serdes.complex/cis->repeated serdes.core/cis->String is)]
               2 [:contracts (serdes.complex/cis->repeated ecis->ContractAbi is)]
               9 [:meta (ecis->FileMeta is)]
               6 [:instances (serdes.complex/cis->repeated ecis->ContractInstance is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StreamlineFile-record)))

(defn ecis->StreamlineFile
  "Embedded CodedInputStream to StreamlineFile"
  [is]
  (serdes.core/cis->embedded cis->StreamlineFile is))

(defn new-StreamlineFile
  "Creates a new instance from a map, similar to map->StreamlineFile except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StreamlineFile-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StreamlineFile-spec init))))]}
  (-> (merge StreamlineFile-defaults init)
      (cond-> (some? (get init :types)) (update :types #(map new-StructDef %)))
      (cond-> (some? (get init :contracts)) (update :contracts #(map new-ContractAbi %)))
      (cond-> (some? (get init :modules)) (update :modules #(map new-ModuleDef %)))
      (cond-> (some? (get init :instances)) (update :instances #(map new-ContractInstance %)))
      (cond-> (some? (get init :conversions)) (update :conversions #(map new-Conversion %)))
      (cond-> (some? (get init :meta)) (update :meta new-FileMeta))
      (map->StreamlineFile-record)))

(defn pb->StreamlineFile
  "Protobuf to StreamlineFile"
  [input]
  (cis->StreamlineFile (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StreamlineFile-meta {:type "spyglass.streamline.alpha.ast.StreamlineFile" :decoder pb->StreamlineFile})

;-----------------------------------------------------------------------------
; FunctionCall
;-----------------------------------------------------------------------------
(defrecord FunctionCall-record [identifier arguments]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:identifier this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:arguments this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.FunctionCall"))

(s/def :spyglass.streamline.alpha.ast.FunctionCall/identifier string?)

(s/def ::FunctionCall-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.FunctionCall/identifier ]))
(def FunctionCall-defaults {:identifier "" :arguments [] })

(defn cis->FunctionCall
  "CodedInputStream to FunctionCall"
  [is]
  (->> (tag-map FunctionCall-defaults
         (fn [tag index]
             (case index
               1 [:identifier (serdes.core/cis->String is)]
               2 [:arguments (serdes.complex/cis->repeated ecis->Expression is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FunctionCall-record)))

(defn ecis->FunctionCall
  "Embedded CodedInputStream to FunctionCall"
  [is]
  (serdes.core/cis->embedded cis->FunctionCall is))

(defn new-FunctionCall
  "Creates a new instance from a map, similar to map->FunctionCall except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FunctionCall-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FunctionCall-spec init))))]}
  (-> (merge FunctionCall-defaults init)
      (cond-> (some? (get init :arguments)) (update :arguments #(map new-Expression %)))
      (map->FunctionCall-record)))

(defn pb->FunctionCall
  "Protobuf to FunctionCall"
  [input]
  (cis->FunctionCall (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FunctionCall-meta {:type "spyglass.streamline.alpha.ast.FunctionCall" :decoder pb->FunctionCall})

;-----------------------------------------------------------------------------
; Conversion
;-----------------------------------------------------------------------------
(defrecord Conversion-record [from to pipeline]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:from this) os)
    (serdes.core/write-String 2  {:optimize true} (:to this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 5 (:pipeline this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.Conversion"))

(s/def :spyglass.streamline.alpha.ast.Conversion/from string?)
(s/def :spyglass.streamline.alpha.ast.Conversion/to string?)

(s/def ::Conversion-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.Conversion/from :spyglass.streamline.alpha.ast.Conversion/to ]))
(def Conversion-defaults {:from "" :to "" :pipeline [] })

(defn cis->Conversion
  "CodedInputStream to Conversion"
  [is]
  (->> (tag-map Conversion-defaults
         (fn [tag index]
             (case index
               1 [:from (serdes.core/cis->String is)]
               2 [:to (serdes.core/cis->String is)]
               5 [:pipeline (serdes.complex/cis->repeated ecis->Function is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Conversion-record)))

(defn ecis->Conversion
  "Embedded CodedInputStream to Conversion"
  [is]
  (serdes.core/cis->embedded cis->Conversion is))

(defn new-Conversion
  "Creates a new instance from a map, similar to map->Conversion except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Conversion-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Conversion-spec init))))]}
  (-> (merge Conversion-defaults init)
      (cond-> (some? (get init :pipeline)) (update :pipeline #(map new-Function %)))
      (map->Conversion-record)))

(defn pb->Conversion
  "Protobuf to Conversion"
  [input]
  (cis->Conversion (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Conversion-meta {:type "spyglass.streamline.alpha.ast.Conversion" :decoder pb->Conversion})

;-----------------------------------------------------------------------------
; Function
;-----------------------------------------------------------------------------
(defrecord Function-record [function]
  pb/Writer
  (serialize [this os]
    (write-Function-function  (:function this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.Function"))

(s/def ::Function-spec (s/keys :opt-un []))
(def Function-defaults {})

(defn cis->Function
  "CodedInputStream to Function"
  [is]
  (->> (tag-map Function-defaults
         (fn [tag index]
             (case index
               1 [:function {:lambda (ecis->Lambda is)}]
               2 [:function {:hof (ecis->Hof is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Function-record)))

(defn ecis->Function
  "Embedded CodedInputStream to Function"
  [is]
  (serdes.core/cis->embedded cis->Function is))

(defn new-Function
  "Creates a new instance from a map, similar to map->Function except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Function-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Function-spec init))))]}
  (-> (merge Function-defaults init)
      (convert-Function-function)
      (map->Function-record)))

(defn pb->Function
  "Protobuf to Function"
  [input]
  (cis->Function (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Function-meta {:type "spyglass.streamline.alpha.ast.Function" :decoder pb->Function})

;-----------------------------------------------------------------------------
; Hof
;-----------------------------------------------------------------------------
(defrecord Hof-record [parent inputs body]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:parent this) os)
    (serdes.complex/write-repeated serdes.core/write-String 2 (:inputs this) os)
    (serdes.core/write-embedded 3 (:body this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.Hof"))

(s/def :spyglass.streamline.alpha.ast.Hof/parent string?)
(s/def :spyglass.streamline.alpha.ast.Hof/inputs (s/every string?))

(s/def ::Hof-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.Hof/parent :spyglass.streamline.alpha.ast.Hof/inputs ]))
(def Hof-defaults {:parent "" :inputs [] })

(defn cis->Hof
  "CodedInputStream to Hof"
  [is]
  (->> (tag-map Hof-defaults
         (fn [tag index]
             (case index
               1 [:parent (serdes.core/cis->String is)]
               2 [:inputs (serdes.complex/cis->repeated serdes.core/cis->String is)]
               3 [:body (ecis->Expression is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Hof-record)))

(defn ecis->Hof
  "Embedded CodedInputStream to Hof"
  [is]
  (serdes.core/cis->embedded cis->Hof is))

(defn new-Hof
  "Creates a new instance from a map, similar to map->Hof except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Hof-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Hof-spec init))))]}
  (-> (merge Hof-defaults init)
      (cond-> (some? (get init :body)) (update :body new-Expression))
      (map->Hof-record)))

(defn pb->Hof
  "Protobuf to Hof"
  [input]
  (cis->Hof (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Hof-meta {:type "spyglass.streamline.alpha.ast.Hof" :decoder pb->Hof})

;-----------------------------------------------------------------------------
; FunctionInput
;-----------------------------------------------------------------------------
(defrecord FunctionInput-record [name type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-String 2  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.FunctionInput"))

(s/def :spyglass.streamline.alpha.ast.FunctionInput/name string?)
(s/def :spyglass.streamline.alpha.ast.FunctionInput/type string?)
(s/def ::FunctionInput-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.FunctionInput/name :spyglass.streamline.alpha.ast.FunctionInput/type ]))
(def FunctionInput-defaults {:name "" :type "" })

(defn cis->FunctionInput
  "CodedInputStream to FunctionInput"
  [is]
  (->> (tag-map FunctionInput-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FunctionInput-record)))

(defn ecis->FunctionInput
  "Embedded CodedInputStream to FunctionInput"
  [is]
  (serdes.core/cis->embedded cis->FunctionInput is))

(defn new-FunctionInput
  "Creates a new instance from a map, similar to map->FunctionInput except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FunctionInput-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FunctionInput-spec init))))]}
  (-> (merge FunctionInput-defaults init)
      (map->FunctionInput-record)))

(defn pb->FunctionInput
  "Protobuf to FunctionInput"
  [input]
  (cis->FunctionInput (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FunctionInput-meta {:type "spyglass.streamline.alpha.ast.FunctionInput" :decoder pb->FunctionInput})

;-----------------------------------------------------------------------------
; ModuleDef
;-----------------------------------------------------------------------------
(defrecord ModuleDef-record [kind identifier signature pipeline]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:kind this) os)
    (serdes.core/write-String 2  {:optimize true} (:identifier this) os)
    (serdes.core/write-embedded 3 (:signature this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 5 (:pipeline this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.ModuleDef"))

(s/def :spyglass.streamline.alpha.ast.ModuleDef/kind string?)
(s/def :spyglass.streamline.alpha.ast.ModuleDef/identifier string?)


(s/def ::ModuleDef-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.ModuleDef/kind :spyglass.streamline.alpha.ast.ModuleDef/identifier ]))
(def ModuleDef-defaults {:kind "" :identifier "" :pipeline [] })

(defn cis->ModuleDef
  "CodedInputStream to ModuleDef"
  [is]
  (->> (tag-map ModuleDef-defaults
         (fn [tag index]
             (case index
               1 [:kind (serdes.core/cis->String is)]
               2 [:identifier (serdes.core/cis->String is)]
               3 [:signature (ecis->ModuleSignature is)]
               5 [:pipeline (serdes.complex/cis->repeated ecis->Function is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ModuleDef-record)))

(defn ecis->ModuleDef
  "Embedded CodedInputStream to ModuleDef"
  [is]
  (serdes.core/cis->embedded cis->ModuleDef is))

(defn new-ModuleDef
  "Creates a new instance from a map, similar to map->ModuleDef except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ModuleDef-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ModuleDef-spec init))))]}
  (-> (merge ModuleDef-defaults init)
      (cond-> (some? (get init :signature)) (update :signature new-ModuleSignature))
      (cond-> (some? (get init :pipeline)) (update :pipeline #(map new-Function %)))
      (map->ModuleDef-record)))

(defn pb->ModuleDef
  "Protobuf to ModuleDef"
  [input]
  (cis->ModuleDef (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ModuleDef-meta {:type "spyglass.streamline.alpha.ast.ModuleDef" :decoder pb->ModuleDef})

;-----------------------------------------------------------------------------
; ModuleSignature
;-----------------------------------------------------------------------------
(defrecord ModuleSignature-record [inputs output]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-String 1 (:inputs this) os)
    (serdes.core/write-String 2  {:optimize true} (:output this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.ModuleSignature"))

(s/def :spyglass.streamline.alpha.ast.ModuleSignature/inputs (s/every string?))
(s/def :spyglass.streamline.alpha.ast.ModuleSignature/output string?)
(s/def ::ModuleSignature-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.ModuleSignature/inputs :spyglass.streamline.alpha.ast.ModuleSignature/output ]))
(def ModuleSignature-defaults {:inputs [] :output "" })

(defn cis->ModuleSignature
  "CodedInputStream to ModuleSignature"
  [is]
  (->> (tag-map ModuleSignature-defaults
         (fn [tag index]
             (case index
               1 [:inputs (serdes.complex/cis->repeated serdes.core/cis->String is)]
               2 [:output (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ModuleSignature-record)))

(defn ecis->ModuleSignature
  "Embedded CodedInputStream to ModuleSignature"
  [is]
  (serdes.core/cis->embedded cis->ModuleSignature is))

(defn new-ModuleSignature
  "Creates a new instance from a map, similar to map->ModuleSignature except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ModuleSignature-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ModuleSignature-spec init))))]}
  (-> (merge ModuleSignature-defaults init)
      (map->ModuleSignature-record)))

(defn pb->ModuleSignature
  "Protobuf to ModuleSignature"
  [input]
  (cis->ModuleSignature (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ModuleSignature-meta {:type "spyglass.streamline.alpha.ast.ModuleSignature" :decoder pb->ModuleSignature})

;-----------------------------------------------------------------------------
; StructField
;-----------------------------------------------------------------------------
(defrecord StructField-record [name type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-String 2  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.StructField"))

(s/def :spyglass.streamline.alpha.ast.StructField/name string?)
(s/def :spyglass.streamline.alpha.ast.StructField/type string?)
(s/def ::StructField-spec (s/keys :opt-un [:spyglass.streamline.alpha.ast.StructField/name :spyglass.streamline.alpha.ast.StructField/type ]))
(def StructField-defaults {:name "" :type "" })

(defn cis->StructField
  "CodedInputStream to StructField"
  [is]
  (->> (tag-map StructField-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StructField-record)))

(defn ecis->StructField
  "Embedded CodedInputStream to StructField"
  [is]
  (serdes.core/cis->embedded cis->StructField is))

(defn new-StructField
  "Creates a new instance from a map, similar to map->StructField except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StructField-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StructField-spec init))))]}
  (-> (merge StructField-defaults init)
      (map->StructField-record)))

(defn pb->StructField
  "Protobuf to StructField"
  [input]
  (cis->StructField (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StructField-meta {:type "spyglass.streamline.alpha.ast.StructField" :decoder pb->StructField})

;-----------------------------------------------------------------------------
; Literal
;-----------------------------------------------------------------------------
(defrecord Literal-record [literal]
  pb/Writer
  (serialize [this os]
    (write-Literal-literal  (:literal this) os))
  pb/TypeReflection
  (gettype [this]
    "spyglass.streamline.alpha.ast.Literal"))

(s/def ::Literal-spec (s/keys :opt-un []))
(def Literal-defaults {})

(defn cis->Literal
  "CodedInputStream to Literal"
  [is]
  (->> (tag-map Literal-defaults
         (fn [tag index]
             (case index
               1 [:literal {:int (serdes.core/cis->Int64 is)}]
               2 [:literal {:str (serdes.core/cis->String is)}]
               3 [:literal {:boolean (serdes.core/cis->Bool is)}]
               4 [:literal {:struct (ecis->StructLiteral is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Literal-record)))

(defn ecis->Literal
  "Embedded CodedInputStream to Literal"
  [is]
  (serdes.core/cis->embedded cis->Literal is))

(defn new-Literal
  "Creates a new instance from a map, similar to map->Literal except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Literal-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Literal-spec init))))]}
  (-> (merge Literal-defaults init)
      (convert-Literal-literal)
      (map->Literal-record)))

(defn pb->Literal
  "Protobuf to Literal"
  [input]
  (cis->Literal (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Literal-meta {:type "spyglass.streamline.alpha.ast.Literal" :decoder pb->Literal})

