;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package sf.substreams.v1
;;;----------------------------------------------------------------------------------
(ns sf.substreams.v1
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [sf.substreams.v1 :as sf.substreams.v1]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->ModuleMetadata)
(declare ecis->ModuleMetadata)
(declare new-ModuleMetadata)
(declare cis->BlockRef)
(declare ecis->BlockRef)
(declare new-BlockRef)
(declare cis->Module-KindMap)
(declare ecis->Module-KindMap)
(declare new-Module-KindMap)
(declare cis->Package)
(declare ecis->Package)
(declare new-Package)
(declare cis->Module-Input-Params)
(declare ecis->Module-Input-Params)
(declare new-Module-Input-Params)
(declare cis->Module)
(declare ecis->Module)
(declare new-Module)
(declare cis->Module-Input-Map)
(declare ecis->Module-Input-Map)
(declare new-Module-Input-Map)
(declare cis->Modules)
(declare ecis->Modules)
(declare new-Modules)
(declare cis->Clock)
(declare ecis->Clock)
(declare new-Clock)
(declare cis->Module-Input)
(declare ecis->Module-Input)
(declare new-Module-Input)
(declare cis->Module-KindStore)
(declare ecis->Module-KindStore)
(declare new-Module-KindStore)
(declare cis->Binary)
(declare ecis->Binary)
(declare new-Binary)
(declare cis->Module-Input-Store)
(declare ecis->Module-Input-Store)
(declare new-Module-Input-Store)
(declare cis->PackageMetadata)
(declare ecis->PackageMetadata)
(declare new-PackageMetadata)
(declare cis->Module-Output)
(declare ecis->Module-Output)
(declare new-Module-Output)
(declare cis->Module-Input-Source)
(declare ecis->Module-Input-Source)
(declare new-Module-Input-Source)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Module-KindStore-UpdatePolicy
;-----------------------------------------------------------------------------
(def Module-KindStore-UpdatePolicy-default :update-policy-unset)

(def Module-KindStore-UpdatePolicy-val2label {
  0 :update-policy-unset
  1 :update-policy-set
  2 :update-policy-set-if-not-exists
  3 :update-policy-add
  4 :update-policy-min
  5 :update-policy-max
  6 :update-policy-append})

(def Module-KindStore-UpdatePolicy-label2val (set/map-invert Module-KindStore-UpdatePolicy-val2label))

(defn cis->Module-KindStore-UpdatePolicy [is]
  (let [val (serdes.core/cis->Enum is)]
    (get Module-KindStore-UpdatePolicy-val2label val val)))

(defn- get-Module-KindStore-UpdatePolicy [value]
  {:pre [(or (int? value) (contains? Module-KindStore-UpdatePolicy-label2val value))]}
  (get Module-KindStore-UpdatePolicy-label2val value value))

(defn write-Module-KindStore-UpdatePolicy
  ([tag value os] (write-Module-KindStore-UpdatePolicy tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-Module-KindStore-UpdatePolicy value) os)))

;-----------------------------------------------------------------------------
; Module-Input-Store-Mode
;-----------------------------------------------------------------------------
(def Module-Input-Store-Mode-default :unset)

(def Module-Input-Store-Mode-val2label {
  0 :unset
  1 :get
  2 :deltas})

(def Module-Input-Store-Mode-label2val (set/map-invert Module-Input-Store-Mode-val2label))

(defn cis->Module-Input-Store-Mode [is]
  (let [val (serdes.core/cis->Enum is)]
    (get Module-Input-Store-Mode-val2label val val)))

(defn- get-Module-Input-Store-Mode [value]
  {:pre [(or (int? value) (contains? Module-Input-Store-Mode-label2val value))]}
  (get Module-Input-Store-Mode-label2val value value))

(defn write-Module-Input-Store-Mode
  ([tag value os] (write-Module-Input-Store-Mode tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-Module-Input-Store-Mode value) os)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Module-kind's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Module-kind [origkeyval]
  (cond
     (get-in origkeyval [:kind :kind-map]) (update-in origkeyval [:kind :kind-map] new-Module-KindMap)
     (get-in origkeyval [:kind :kind-store]) (update-in origkeyval [:kind :kind-store] new-Module-KindStore)
     :default origkeyval))

(defn write-Module-kind [kind os]
  (let [field (first kind)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :kind-map (serdes.core/write-embedded 2 v os)
         :kind-store (serdes.core/write-embedded 3 v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Module-Input-input's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Module-Input-input [origkeyval]
  (cond
     (get-in origkeyval [:input :source]) (update-in origkeyval [:input :source] new-Module-Input-Source)
     (get-in origkeyval [:input :map]) (update-in origkeyval [:input :map] new-Module-Input-Map)
     (get-in origkeyval [:input :store]) (update-in origkeyval [:input :store] new-Module-Input-Store)
     (get-in origkeyval [:input :params]) (update-in origkeyval [:input :params] new-Module-Input-Params)
     :default origkeyval))

(defn write-Module-Input-input [input os]
  (let [field (first input)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :source (serdes.core/write-embedded 1 v os)
         :map (serdes.core/write-embedded 2 v os)
         :store (serdes.core/write-embedded 3 v os)
         :params (serdes.core/write-embedded 4 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ModuleMetadata
;-----------------------------------------------------------------------------
(defrecord ModuleMetadata-record [package-index doc]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:package-index this) os)
    (serdes.core/write-String 2  {:optimize true} (:doc this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.ModuleMetadata"))

(s/def :sf.substreams.v1.ModuleMetadata/package-index int?)
(s/def :sf.substreams.v1.ModuleMetadata/doc string?)
(s/def ::ModuleMetadata-spec (s/keys :opt-un [:sf.substreams.v1.ModuleMetadata/package-index :sf.substreams.v1.ModuleMetadata/doc ]))
(def ModuleMetadata-defaults {:package-index 0 :doc "" })

(defn cis->ModuleMetadata
  "CodedInputStream to ModuleMetadata"
  [is]
  (->> (tag-map ModuleMetadata-defaults
         (fn [tag index]
             (case index
               1 [:package-index (serdes.core/cis->UInt64 is)]
               2 [:doc (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ModuleMetadata-record)))

(defn ecis->ModuleMetadata
  "Embedded CodedInputStream to ModuleMetadata"
  [is]
  (serdes.core/cis->embedded cis->ModuleMetadata is))

(defn new-ModuleMetadata
  "Creates a new instance from a map, similar to map->ModuleMetadata except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ModuleMetadata-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ModuleMetadata-spec init))))]}
  (-> (merge ModuleMetadata-defaults init)
      (map->ModuleMetadata-record)))

(defn pb->ModuleMetadata
  "Protobuf to ModuleMetadata"
  [input]
  (cis->ModuleMetadata (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ModuleMetadata-meta {:type "sf.substreams.v1.ModuleMetadata" :decoder pb->ModuleMetadata})

;-----------------------------------------------------------------------------
; BlockRef
;-----------------------------------------------------------------------------
(defrecord BlockRef-record [id number]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:id this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:number this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.BlockRef"))

(s/def :sf.substreams.v1.BlockRef/id string?)
(s/def :sf.substreams.v1.BlockRef/number int?)
(s/def ::BlockRef-spec (s/keys :opt-un [:sf.substreams.v1.BlockRef/id :sf.substreams.v1.BlockRef/number ]))
(def BlockRef-defaults {:id "" :number 0 })

(defn cis->BlockRef
  "CodedInputStream to BlockRef"
  [is]
  (->> (tag-map BlockRef-defaults
         (fn [tag index]
             (case index
               1 [:id (serdes.core/cis->String is)]
               2 [:number (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockRef-record)))

(defn ecis->BlockRef
  "Embedded CodedInputStream to BlockRef"
  [is]
  (serdes.core/cis->embedded cis->BlockRef is))

(defn new-BlockRef
  "Creates a new instance from a map, similar to map->BlockRef except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockRef-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockRef-spec init))))]}
  (-> (merge BlockRef-defaults init)
      (map->BlockRef-record)))

(defn pb->BlockRef
  "Protobuf to BlockRef"
  [input]
  (cis->BlockRef (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockRef-meta {:type "sf.substreams.v1.BlockRef" :decoder pb->BlockRef})

;-----------------------------------------------------------------------------
; Module-KindMap
;-----------------------------------------------------------------------------
(defrecord Module-KindMap-record [output-type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:output-type this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-KindMap"))

(s/def :sf.substreams.v1.Module-KindMap/output-type string?)
(s/def ::Module-KindMap-spec (s/keys :opt-un [:sf.substreams.v1.Module-KindMap/output-type ]))
(def Module-KindMap-defaults {:output-type "" })

(defn cis->Module-KindMap
  "CodedInputStream to Module-KindMap"
  [is]
  (->> (tag-map Module-KindMap-defaults
         (fn [tag index]
             (case index
               1 [:output-type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-KindMap-record)))

(defn ecis->Module-KindMap
  "Embedded CodedInputStream to Module-KindMap"
  [is]
  (serdes.core/cis->embedded cis->Module-KindMap is))

(defn new-Module-KindMap
  "Creates a new instance from a map, similar to map->Module-KindMap except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-KindMap-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-KindMap-spec init))))]}
  (-> (merge Module-KindMap-defaults init)
      (map->Module-KindMap-record)))

(defn pb->Module-KindMap
  "Protobuf to Module-KindMap"
  [input]
  (cis->Module-KindMap (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-KindMap-meta {:type "sf.substreams.v1.Module-KindMap" :decoder pb->Module-KindMap})

;-----------------------------------------------------------------------------
; Package
;-----------------------------------------------------------------------------
(defrecord Package-record [image modules package-meta proto-files network sink-module module-meta version sink-config]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 12  {:optimize true} (:image this) os)
    (serdes.core/write-embedded 6 (:modules this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 8 (:package-meta this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:proto-files this) os)
    (serdes.core/write-String 9  {:optimize true} (:network this) os)
    (serdes.core/write-String 11  {:optimize true} (:sink-module this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 7 (:module-meta this) os)
    (serdes.core/write-UInt64 5  {:optimize true} (:version this) os)
    (serdes.core/write-embedded 10 (:sink-config this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Package"))

(s/def :sf.substreams.v1.Package/image bytes?)



(s/def :sf.substreams.v1.Package/network string?)
(s/def :sf.substreams.v1.Package/sink-module string?)

(s/def :sf.substreams.v1.Package/version int?)

(s/def ::Package-spec (s/keys :opt-un [:sf.substreams.v1.Package/image :sf.substreams.v1.Package/network :sf.substreams.v1.Package/sink-module :sf.substreams.v1.Package/version ]))
(def Package-defaults {:image (byte-array 0) :package-meta [] :proto-files [] :network "" :sink-module "" :module-meta [] :version 0 })

(defn cis->Package
  "CodedInputStream to Package"
  [is]
  (->> (tag-map Package-defaults
         (fn [tag index]
             (case index
               12 [:image (serdes.core/cis->Bytes is)]
               6 [:modules (ecis->Modules is)]
               8 [:package-meta (serdes.complex/cis->repeated ecis->PackageMetadata is)]
               1 [:proto-files (serdes.complex/cis->repeated com.google.protobuf/ecis->FileDescriptorProto is)]
               9 [:network (serdes.core/cis->String is)]
               11 [:sink-module (serdes.core/cis->String is)]
               7 [:module-meta (serdes.complex/cis->repeated ecis->ModuleMetadata is)]
               5 [:version (serdes.core/cis->UInt64 is)]
               10 [:sink-config (com.google.protobuf/ecis->Any is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Package-record)))

(defn ecis->Package
  "Embedded CodedInputStream to Package"
  [is]
  (serdes.core/cis->embedded cis->Package is))

(defn new-Package
  "Creates a new instance from a map, similar to map->Package except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Package-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Package-spec init))))]}
  (-> (merge Package-defaults init)
      (cond-> (some? (get init :proto-files)) (update :proto-files #(map com.google.protobuf/new-FileDescriptorProto %)))
      (cond-> (some? (get init :modules)) (update :modules new-Modules))
      (cond-> (some? (get init :module-meta)) (update :module-meta #(map new-ModuleMetadata %)))
      (cond-> (some? (get init :package-meta)) (update :package-meta #(map new-PackageMetadata %)))
      (cond-> (some? (get init :sink-config)) (update :sink-config com.google.protobuf/new-Any))
      (map->Package-record)))

(defn pb->Package
  "Protobuf to Package"
  [input]
  (cis->Package (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Package-meta {:type "sf.substreams.v1.Package" :decoder pb->Package})

;-----------------------------------------------------------------------------
; Module-Input-Params
;-----------------------------------------------------------------------------
(defrecord Module-Input-Params-record [value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-Input-Params"))

(s/def :sf.substreams.v1.Module-Input-Params/value string?)
(s/def ::Module-Input-Params-spec (s/keys :opt-un [:sf.substreams.v1.Module-Input-Params/value ]))
(def Module-Input-Params-defaults {:value "" })

(defn cis->Module-Input-Params
  "CodedInputStream to Module-Input-Params"
  [is]
  (->> (tag-map Module-Input-Params-defaults
         (fn [tag index]
             (case index
               1 [:value (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-Input-Params-record)))

(defn ecis->Module-Input-Params
  "Embedded CodedInputStream to Module-Input-Params"
  [is]
  (serdes.core/cis->embedded cis->Module-Input-Params is))

(defn new-Module-Input-Params
  "Creates a new instance from a map, similar to map->Module-Input-Params except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-Input-Params-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-Input-Params-spec init))))]}
  (-> (merge Module-Input-Params-defaults init)
      (map->Module-Input-Params-record)))

(defn pb->Module-Input-Params
  "Protobuf to Module-Input-Params"
  [input]
  (cis->Module-Input-Params (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-Input-Params-meta {:type "sf.substreams.v1.Module-Input-Params" :decoder pb->Module-Input-Params})

;-----------------------------------------------------------------------------
; Module
;-----------------------------------------------------------------------------
(defrecord Module-record [name kind binary-index binary-entrypoint inputs output initial-block]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (write-Module-kind  (:kind this) os)
    (serdes.core/write-UInt32 4  {:optimize true} (:binary-index this) os)
    (serdes.core/write-String 5  {:optimize true} (:binary-entrypoint this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 6 (:inputs this) os)
    (serdes.core/write-embedded 7 (:output this) os)
    (serdes.core/write-UInt64 8  {:optimize true} (:initial-block this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module"))

(s/def :sf.substreams.v1.Module/name string?)

(s/def :sf.substreams.v1.Module/binary-index int?)
(s/def :sf.substreams.v1.Module/binary-entrypoint string?)


(s/def :sf.substreams.v1.Module/initial-block int?)
(s/def ::Module-spec (s/keys :opt-un [:sf.substreams.v1.Module/name :sf.substreams.v1.Module/binary-index :sf.substreams.v1.Module/binary-entrypoint :sf.substreams.v1.Module/initial-block ]))
(def Module-defaults {:name "" :binary-index 0 :binary-entrypoint "" :inputs [] :initial-block 0 })

(defn cis->Module
  "CodedInputStream to Module"
  [is]
  (->> (tag-map Module-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:kind {:kind-map (ecis->Module-KindMap is)}]
               3 [:kind {:kind-store (ecis->Module-KindStore is)}]
               4 [:binary-index (serdes.core/cis->UInt32 is)]
               5 [:binary-entrypoint (serdes.core/cis->String is)]
               6 [:inputs (serdes.complex/cis->repeated ecis->Module-Input is)]
               7 [:output (ecis->Module-Output is)]
               8 [:initial-block (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-record)))

(defn ecis->Module
  "Embedded CodedInputStream to Module"
  [is]
  (serdes.core/cis->embedded cis->Module is))

(defn new-Module
  "Creates a new instance from a map, similar to map->Module except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-spec init))))]}
  (-> (merge Module-defaults init)
      (cond-> (some? (get init :inputs)) (update :inputs #(map new-Module-Input %)))
      (cond-> (some? (get init :output)) (update :output new-Module-Output))
      (convert-Module-kind)
      (map->Module-record)))

(defn pb->Module
  "Protobuf to Module"
  [input]
  (cis->Module (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-meta {:type "sf.substreams.v1.Module" :decoder pb->Module})

;-----------------------------------------------------------------------------
; Module-Input-Map
;-----------------------------------------------------------------------------
(defrecord Module-Input-Map-record [module-name]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:module-name this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-Input-Map"))

(s/def :sf.substreams.v1.Module-Input-Map/module-name string?)
(s/def ::Module-Input-Map-spec (s/keys :opt-un [:sf.substreams.v1.Module-Input-Map/module-name ]))
(def Module-Input-Map-defaults {:module-name "" })

(defn cis->Module-Input-Map
  "CodedInputStream to Module-Input-Map"
  [is]
  (->> (tag-map Module-Input-Map-defaults
         (fn [tag index]
             (case index
               1 [:module-name (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-Input-Map-record)))

(defn ecis->Module-Input-Map
  "Embedded CodedInputStream to Module-Input-Map"
  [is]
  (serdes.core/cis->embedded cis->Module-Input-Map is))

(defn new-Module-Input-Map
  "Creates a new instance from a map, similar to map->Module-Input-Map except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-Input-Map-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-Input-Map-spec init))))]}
  (-> (merge Module-Input-Map-defaults init)
      (map->Module-Input-Map-record)))

(defn pb->Module-Input-Map
  "Protobuf to Module-Input-Map"
  [input]
  (cis->Module-Input-Map (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-Input-Map-meta {:type "sf.substreams.v1.Module-Input-Map" :decoder pb->Module-Input-Map})

;-----------------------------------------------------------------------------
; Modules
;-----------------------------------------------------------------------------
(defrecord Modules-record [modules binaries]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:modules this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:binaries this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Modules"))

(s/def ::Modules-spec (s/keys :opt-un []))
(def Modules-defaults {:modules [] :binaries [] })

(defn cis->Modules
  "CodedInputStream to Modules"
  [is]
  (->> (tag-map Modules-defaults
         (fn [tag index]
             (case index
               1 [:modules (serdes.complex/cis->repeated ecis->Module is)]
               2 [:binaries (serdes.complex/cis->repeated ecis->Binary is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Modules-record)))

(defn ecis->Modules
  "Embedded CodedInputStream to Modules"
  [is]
  (serdes.core/cis->embedded cis->Modules is))

(defn new-Modules
  "Creates a new instance from a map, similar to map->Modules except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Modules-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Modules-spec init))))]}
  (-> (merge Modules-defaults init)
      (cond-> (some? (get init :modules)) (update :modules #(map new-Module %)))
      (cond-> (some? (get init :binaries)) (update :binaries #(map new-Binary %)))
      (map->Modules-record)))

(defn pb->Modules
  "Protobuf to Modules"
  [input]
  (cis->Modules (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Modules-meta {:type "sf.substreams.v1.Modules" :decoder pb->Modules})

;-----------------------------------------------------------------------------
; Clock
;-----------------------------------------------------------------------------
(defrecord Clock-record [id number timestamp]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:id this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:number this) os)
    (serdes.core/write-embedded 3 (:timestamp this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Clock"))

(s/def :sf.substreams.v1.Clock/id string?)
(s/def :sf.substreams.v1.Clock/number int?)

(s/def ::Clock-spec (s/keys :opt-un [:sf.substreams.v1.Clock/id :sf.substreams.v1.Clock/number ]))
(def Clock-defaults {:id "" :number 0 })

(defn cis->Clock
  "CodedInputStream to Clock"
  [is]
  (->> (tag-map Clock-defaults
         (fn [tag index]
             (case index
               1 [:id (serdes.core/cis->String is)]
               2 [:number (serdes.core/cis->UInt64 is)]
               3 [:timestamp (com.google.protobuf/ecis->Timestamp is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Clock-record)))

(defn ecis->Clock
  "Embedded CodedInputStream to Clock"
  [is]
  (serdes.core/cis->embedded cis->Clock is))

(defn new-Clock
  "Creates a new instance from a map, similar to map->Clock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Clock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Clock-spec init))))]}
  (-> (merge Clock-defaults init)
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (map->Clock-record)))

(defn pb->Clock
  "Protobuf to Clock"
  [input]
  (cis->Clock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Clock-meta {:type "sf.substreams.v1.Clock" :decoder pb->Clock})

;-----------------------------------------------------------------------------
; Module-Input
;-----------------------------------------------------------------------------
(defrecord Module-Input-record [input]
  pb/Writer
  (serialize [this os]
    (write-Module-Input-input  (:input this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-Input"))

(s/def ::Module-Input-spec (s/keys :opt-un []))
(def Module-Input-defaults {})

(defn cis->Module-Input
  "CodedInputStream to Module-Input"
  [is]
  (->> (tag-map Module-Input-defaults
         (fn [tag index]
             (case index
               1 [:input {:source (ecis->Module-Input-Source is)}]
               2 [:input {:map (ecis->Module-Input-Map is)}]
               3 [:input {:store (ecis->Module-Input-Store is)}]
               4 [:input {:params (ecis->Module-Input-Params is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-Input-record)))

(defn ecis->Module-Input
  "Embedded CodedInputStream to Module-Input"
  [is]
  (serdes.core/cis->embedded cis->Module-Input is))

(defn new-Module-Input
  "Creates a new instance from a map, similar to map->Module-Input except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-Input-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-Input-spec init))))]}
  (-> (merge Module-Input-defaults init)
      (convert-Module-Input-input)
      (map->Module-Input-record)))

(defn pb->Module-Input
  "Protobuf to Module-Input"
  [input]
  (cis->Module-Input (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-Input-meta {:type "sf.substreams.v1.Module-Input" :decoder pb->Module-Input})

;-----------------------------------------------------------------------------
; Module-KindStore
;-----------------------------------------------------------------------------
(defrecord Module-KindStore-record [update-policy value-type]
  pb/Writer
  (serialize [this os]
    (write-Module-KindStore-UpdatePolicy 1  {:optimize true} (:update-policy this) os)
    (serdes.core/write-String 2  {:optimize true} (:value-type this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-KindStore"))

(s/def :sf.substreams.v1.Module-KindStore/update-policy (s/or :keyword keyword? :int int?))
(s/def :sf.substreams.v1.Module-KindStore/value-type string?)
(s/def ::Module-KindStore-spec (s/keys :opt-un [:sf.substreams.v1.Module-KindStore/update-policy :sf.substreams.v1.Module-KindStore/value-type ]))
(def Module-KindStore-defaults {:update-policy Module-KindStore-UpdatePolicy-default :value-type "" })

(defn cis->Module-KindStore
  "CodedInputStream to Module-KindStore"
  [is]
  (->> (tag-map Module-KindStore-defaults
         (fn [tag index]
             (case index
               1 [:update-policy (cis->Module-KindStore-UpdatePolicy is)]
               2 [:value-type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-KindStore-record)))

(defn ecis->Module-KindStore
  "Embedded CodedInputStream to Module-KindStore"
  [is]
  (serdes.core/cis->embedded cis->Module-KindStore is))

(defn new-Module-KindStore
  "Creates a new instance from a map, similar to map->Module-KindStore except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-KindStore-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-KindStore-spec init))))]}
  (-> (merge Module-KindStore-defaults init)
      (map->Module-KindStore-record)))

(defn pb->Module-KindStore
  "Protobuf to Module-KindStore"
  [input]
  (cis->Module-KindStore (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-KindStore-meta {:type "sf.substreams.v1.Module-KindStore" :decoder pb->Module-KindStore})

;-----------------------------------------------------------------------------
; Binary
;-----------------------------------------------------------------------------
(defrecord Binary-record [type content]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:content this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Binary"))

(s/def :sf.substreams.v1.Binary/type string?)
(s/def :sf.substreams.v1.Binary/content bytes?)
(s/def ::Binary-spec (s/keys :opt-un [:sf.substreams.v1.Binary/type :sf.substreams.v1.Binary/content ]))
(def Binary-defaults {:type "" :content (byte-array 0) })

(defn cis->Binary
  "CodedInputStream to Binary"
  [is]
  (->> (tag-map Binary-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]
               2 [:content (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Binary-record)))

(defn ecis->Binary
  "Embedded CodedInputStream to Binary"
  [is]
  (serdes.core/cis->embedded cis->Binary is))

(defn new-Binary
  "Creates a new instance from a map, similar to map->Binary except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Binary-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Binary-spec init))))]}
  (-> (merge Binary-defaults init)
      (map->Binary-record)))

(defn pb->Binary
  "Protobuf to Binary"
  [input]
  (cis->Binary (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Binary-meta {:type "sf.substreams.v1.Binary" :decoder pb->Binary})

;-----------------------------------------------------------------------------
; Module-Input-Store
;-----------------------------------------------------------------------------
(defrecord Module-Input-Store-record [module-name mode]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:module-name this) os)
    (write-Module-Input-Store-Mode 2  {:optimize true} (:mode this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-Input-Store"))

(s/def :sf.substreams.v1.Module-Input-Store/module-name string?)
(s/def :sf.substreams.v1.Module-Input-Store/mode (s/or :keyword keyword? :int int?))
(s/def ::Module-Input-Store-spec (s/keys :opt-un [:sf.substreams.v1.Module-Input-Store/module-name :sf.substreams.v1.Module-Input-Store/mode ]))
(def Module-Input-Store-defaults {:module-name "" :mode Module-Input-Store-Mode-default })

(defn cis->Module-Input-Store
  "CodedInputStream to Module-Input-Store"
  [is]
  (->> (tag-map Module-Input-Store-defaults
         (fn [tag index]
             (case index
               1 [:module-name (serdes.core/cis->String is)]
               2 [:mode (cis->Module-Input-Store-Mode is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-Input-Store-record)))

(defn ecis->Module-Input-Store
  "Embedded CodedInputStream to Module-Input-Store"
  [is]
  (serdes.core/cis->embedded cis->Module-Input-Store is))

(defn new-Module-Input-Store
  "Creates a new instance from a map, similar to map->Module-Input-Store except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-Input-Store-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-Input-Store-spec init))))]}
  (-> (merge Module-Input-Store-defaults init)
      (map->Module-Input-Store-record)))

(defn pb->Module-Input-Store
  "Protobuf to Module-Input-Store"
  [input]
  (cis->Module-Input-Store (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-Input-Store-meta {:type "sf.substreams.v1.Module-Input-Store" :decoder pb->Module-Input-Store})

;-----------------------------------------------------------------------------
; PackageMetadata
;-----------------------------------------------------------------------------
(defrecord PackageMetadata-record [version url name doc]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:version this) os)
    (serdes.core/write-String 2  {:optimize true} (:url this) os)
    (serdes.core/write-String 3  {:optimize true} (:name this) os)
    (serdes.core/write-String 4  {:optimize true} (:doc this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.PackageMetadata"))

(s/def :sf.substreams.v1.PackageMetadata/version string?)
(s/def :sf.substreams.v1.PackageMetadata/url string?)
(s/def :sf.substreams.v1.PackageMetadata/name string?)
(s/def :sf.substreams.v1.PackageMetadata/doc string?)
(s/def ::PackageMetadata-spec (s/keys :opt-un [:sf.substreams.v1.PackageMetadata/version :sf.substreams.v1.PackageMetadata/url :sf.substreams.v1.PackageMetadata/name :sf.substreams.v1.PackageMetadata/doc ]))
(def PackageMetadata-defaults {:version "" :url "" :name "" :doc "" })

(defn cis->PackageMetadata
  "CodedInputStream to PackageMetadata"
  [is]
  (->> (tag-map PackageMetadata-defaults
         (fn [tag index]
             (case index
               1 [:version (serdes.core/cis->String is)]
               2 [:url (serdes.core/cis->String is)]
               3 [:name (serdes.core/cis->String is)]
               4 [:doc (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PackageMetadata-record)))

(defn ecis->PackageMetadata
  "Embedded CodedInputStream to PackageMetadata"
  [is]
  (serdes.core/cis->embedded cis->PackageMetadata is))

(defn new-PackageMetadata
  "Creates a new instance from a map, similar to map->PackageMetadata except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PackageMetadata-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PackageMetadata-spec init))))]}
  (-> (merge PackageMetadata-defaults init)
      (map->PackageMetadata-record)))

(defn pb->PackageMetadata
  "Protobuf to PackageMetadata"
  [input]
  (cis->PackageMetadata (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PackageMetadata-meta {:type "sf.substreams.v1.PackageMetadata" :decoder pb->PackageMetadata})

;-----------------------------------------------------------------------------
; Module-Output
;-----------------------------------------------------------------------------
(defrecord Module-Output-record [type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-Output"))

(s/def :sf.substreams.v1.Module-Output/type string?)
(s/def ::Module-Output-spec (s/keys :opt-un [:sf.substreams.v1.Module-Output/type ]))
(def Module-Output-defaults {:type "" })

(defn cis->Module-Output
  "CodedInputStream to Module-Output"
  [is]
  (->> (tag-map Module-Output-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-Output-record)))

(defn ecis->Module-Output
  "Embedded CodedInputStream to Module-Output"
  [is]
  (serdes.core/cis->embedded cis->Module-Output is))

(defn new-Module-Output
  "Creates a new instance from a map, similar to map->Module-Output except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-Output-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-Output-spec init))))]}
  (-> (merge Module-Output-defaults init)
      (map->Module-Output-record)))

(defn pb->Module-Output
  "Protobuf to Module-Output"
  [input]
  (cis->Module-Output (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-Output-meta {:type "sf.substreams.v1.Module-Output" :decoder pb->Module-Output})

;-----------------------------------------------------------------------------
; Module-Input-Source
;-----------------------------------------------------------------------------
(defrecord Module-Input-Source-record [type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.v1.Module-Input-Source"))

(s/def :sf.substreams.v1.Module-Input-Source/type string?)
(s/def ::Module-Input-Source-spec (s/keys :opt-un [:sf.substreams.v1.Module-Input-Source/type ]))
(def Module-Input-Source-defaults {:type "" })

(defn cis->Module-Input-Source
  "CodedInputStream to Module-Input-Source"
  [is]
  (->> (tag-map Module-Input-Source-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Module-Input-Source-record)))

(defn ecis->Module-Input-Source
  "Embedded CodedInputStream to Module-Input-Source"
  [is]
  (serdes.core/cis->embedded cis->Module-Input-Source is))

(defn new-Module-Input-Source
  "Creates a new instance from a map, similar to map->Module-Input-Source except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Module-Input-Source-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Module-Input-Source-spec init))))]}
  (-> (merge Module-Input-Source-defaults init)
      (map->Module-Input-Source-record)))

(defn pb->Module-Input-Source
  "Protobuf to Module-Input-Source"
  [input]
  (cis->Module-Input-Source (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Module-Input-Source-meta {:type "sf.substreams.v1.Module-Input-Source" :decoder pb->Module-Input-Source})

