;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package sf.substreams.rpc.v2
;;;----------------------------------------------------------------------------------
(ns sf.substreams.rpc.v2
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [sf.substreams.v1 :as sf.substreams.v1]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->ModulesProgress)
(declare ecis->ModulesProgress)
(declare new-ModulesProgress)
(declare cis->Request)
(declare ecis->Request)
(declare new-Request)
(declare cis->MapModuleOutput)
(declare ecis->MapModuleOutput)
(declare new-MapModuleOutput)
(declare cis->BlockRange)
(declare ecis->BlockRange)
(declare new-BlockRange)
(declare cis->StoreDelta)
(declare ecis->StoreDelta)
(declare new-StoreDelta)
(declare cis->OutputDebugInfo)
(declare ecis->OutputDebugInfo)
(declare new-OutputDebugInfo)
(declare cis->InitialSnapshotComplete)
(declare ecis->InitialSnapshotComplete)
(declare new-InitialSnapshotComplete)
(declare cis->InitialSnapshotData)
(declare ecis->InitialSnapshotData)
(declare new-InitialSnapshotData)
(declare cis->Response)
(declare ecis->Response)
(declare new-Response)
(declare cis->StoreModuleOutput)
(declare ecis->StoreModuleOutput)
(declare new-StoreModuleOutput)
(declare cis->ProcessedBytes)
(declare ecis->ProcessedBytes)
(declare new-ProcessedBytes)
(declare cis->ModuleStats)
(declare ecis->ModuleStats)
(declare new-ModuleStats)
(declare cis->BlockScopedData)
(declare ecis->BlockScopedData)
(declare new-BlockScopedData)
(declare cis->SessionInit)
(declare ecis->SessionInit)
(declare new-SessionInit)
(declare cis->ExternalCallMetric)
(declare ecis->ExternalCallMetric)
(declare new-ExternalCallMetric)
(declare cis->Error)
(declare ecis->Error)
(declare new-Error)
(declare cis->Job)
(declare ecis->Job)
(declare new-Job)
(declare cis->Stage)
(declare ecis->Stage)
(declare new-Stage)
(declare cis->BlockUndoSignal)
(declare ecis->BlockUndoSignal)
(declare new-BlockUndoSignal)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; StoreDelta-Operation
;-----------------------------------------------------------------------------
(def StoreDelta-Operation-default :unset)

(def StoreDelta-Operation-val2label {
  0 :unset
  1 :create
  2 :update
  3 :delete})

(def StoreDelta-Operation-label2val (set/map-invert StoreDelta-Operation-val2label))

(defn cis->StoreDelta-Operation [is]
  (let [val (serdes.core/cis->Enum is)]
    (get StoreDelta-Operation-val2label val val)))

(defn- get-StoreDelta-Operation [value]
  {:pre [(or (int? value) (contains? StoreDelta-Operation-label2val value))]}
  (get StoreDelta-Operation-label2val value value))

(defn write-StoreDelta-Operation
  ([tag value os] (write-StoreDelta-Operation tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-StoreDelta-Operation value) os)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Response-message's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Response-message [origkeyval]
  (cond
     (get-in origkeyval [:message :session]) (update-in origkeyval [:message :session] new-SessionInit)
     (get-in origkeyval [:message :progress]) (update-in origkeyval [:message :progress] new-ModulesProgress)
     (get-in origkeyval [:message :block-scoped-data]) (update-in origkeyval [:message :block-scoped-data] new-BlockScopedData)
     (get-in origkeyval [:message :block-undo-signal]) (update-in origkeyval [:message :block-undo-signal] new-BlockUndoSignal)
     (get-in origkeyval [:message :fatal-error]) (update-in origkeyval [:message :fatal-error] new-Error)
     (get-in origkeyval [:message :debug-snapshot-data]) (update-in origkeyval [:message :debug-snapshot-data] new-InitialSnapshotData)
     (get-in origkeyval [:message :debug-snapshot-complete]) (update-in origkeyval [:message :debug-snapshot-complete] new-InitialSnapshotComplete)
     :default origkeyval))

(defn write-Response-message [message os]
  (let [field (first message)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :session (serdes.core/write-embedded 1 v os)
         :progress (serdes.core/write-embedded 2 v os)
         :block-scoped-data (serdes.core/write-embedded 3 v os)
         :block-undo-signal (serdes.core/write-embedded 4 v os)
         :fatal-error (serdes.core/write-embedded 5 v os)
         :debug-snapshot-data (serdes.core/write-embedded 10 v os)
         :debug-snapshot-complete (serdes.core/write-embedded 11 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ModulesProgress
;-----------------------------------------------------------------------------
(defrecord ModulesProgress-record [running-jobs modules-stats stages processed-bytes]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:running-jobs this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:modules-stats this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:stages this) os)
    (serdes.core/write-embedded 5 (:processed-bytes this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.ModulesProgress"))

(s/def ::ModulesProgress-spec (s/keys :opt-un []))
(def ModulesProgress-defaults {:running-jobs [] :modules-stats [] :stages [] })

(defn cis->ModulesProgress
  "CodedInputStream to ModulesProgress"
  [is]
  (->> (tag-map ModulesProgress-defaults
         (fn [tag index]
             (case index
               2 [:running-jobs (serdes.complex/cis->repeated ecis->Job is)]
               3 [:modules-stats (serdes.complex/cis->repeated ecis->ModuleStats is)]
               4 [:stages (serdes.complex/cis->repeated ecis->Stage is)]
               5 [:processed-bytes (ecis->ProcessedBytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ModulesProgress-record)))

(defn ecis->ModulesProgress
  "Embedded CodedInputStream to ModulesProgress"
  [is]
  (serdes.core/cis->embedded cis->ModulesProgress is))

(defn new-ModulesProgress
  "Creates a new instance from a map, similar to map->ModulesProgress except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ModulesProgress-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ModulesProgress-spec init))))]}
  (-> (merge ModulesProgress-defaults init)
      (cond-> (some? (get init :running-jobs)) (update :running-jobs #(map new-Job %)))
      (cond-> (some? (get init :modules-stats)) (update :modules-stats #(map new-ModuleStats %)))
      (cond-> (some? (get init :stages)) (update :stages #(map new-Stage %)))
      (cond-> (some? (get init :processed-bytes)) (update :processed-bytes new-ProcessedBytes))
      (map->ModulesProgress-record)))

(defn pb->ModulesProgress
  "Protobuf to ModulesProgress"
  [input]
  (cis->ModulesProgress (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ModulesProgress-meta {:type "sf.substreams.rpc.v2.ModulesProgress" :decoder pb->ModulesProgress})

;-----------------------------------------------------------------------------
; Request
;-----------------------------------------------------------------------------
(defrecord Request-record [start-block-num start-cursor stop-block-num final-blocks-only production-mode output-module modules debug-initial-store-snapshot-for-modules]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:start-block-num this) os)
    (serdes.core/write-String 2  {:optimize true} (:start-cursor this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:stop-block-num this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:final-blocks-only this) os)
    (serdes.core/write-Bool 5  {:optimize true} (:production-mode this) os)
    (serdes.core/write-String 6  {:optimize true} (:output-module this) os)
    (serdes.core/write-embedded 7 (:modules this) os)
    (serdes.complex/write-repeated serdes.core/write-String 10 (:debug-initial-store-snapshot-for-modules this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.Request"))

(s/def :sf.substreams.rpc.v2.Request/start-block-num int?)
(s/def :sf.substreams.rpc.v2.Request/start-cursor string?)
(s/def :sf.substreams.rpc.v2.Request/stop-block-num int?)
(s/def :sf.substreams.rpc.v2.Request/final-blocks-only boolean?)
(s/def :sf.substreams.rpc.v2.Request/production-mode boolean?)
(s/def :sf.substreams.rpc.v2.Request/output-module string?)

(s/def :sf.substreams.rpc.v2.Request/debug-initial-store-snapshot-for-modules (s/every string?))
(s/def ::Request-spec (s/keys :opt-un [:sf.substreams.rpc.v2.Request/start-block-num :sf.substreams.rpc.v2.Request/start-cursor :sf.substreams.rpc.v2.Request/stop-block-num :sf.substreams.rpc.v2.Request/final-blocks-only :sf.substreams.rpc.v2.Request/production-mode :sf.substreams.rpc.v2.Request/output-module :sf.substreams.rpc.v2.Request/debug-initial-store-snapshot-for-modules ]))
(def Request-defaults {:start-block-num 0 :start-cursor "" :stop-block-num 0 :final-blocks-only false :production-mode false :output-module "" :debug-initial-store-snapshot-for-modules [] })

(defn cis->Request
  "CodedInputStream to Request"
  [is]
  (->> (tag-map Request-defaults
         (fn [tag index]
             (case index
               1 [:start-block-num (serdes.core/cis->Int64 is)]
               2 [:start-cursor (serdes.core/cis->String is)]
               3 [:stop-block-num (serdes.core/cis->UInt64 is)]
               4 [:final-blocks-only (serdes.core/cis->Bool is)]
               5 [:production-mode (serdes.core/cis->Bool is)]
               6 [:output-module (serdes.core/cis->String is)]
               7 [:modules (sf.substreams.v1/ecis->Modules is)]
               10 [:debug-initial-store-snapshot-for-modules (serdes.complex/cis->repeated serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Request-record)))

(defn ecis->Request
  "Embedded CodedInputStream to Request"
  [is]
  (serdes.core/cis->embedded cis->Request is))

(defn new-Request
  "Creates a new instance from a map, similar to map->Request except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Request-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Request-spec init))))]}
  (-> (merge Request-defaults init)
      (cond-> (some? (get init :modules)) (update :modules sf.substreams.v1/new-Modules))
      (map->Request-record)))

(defn pb->Request
  "Protobuf to Request"
  [input]
  (cis->Request (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Request-meta {:type "sf.substreams.rpc.v2.Request" :decoder pb->Request})

;-----------------------------------------------------------------------------
; MapModuleOutput
;-----------------------------------------------------------------------------
(defrecord MapModuleOutput-record [name map-output debug-info]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-embedded 2 (:map-output this) os)
    (serdes.core/write-embedded 10 (:debug-info this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.MapModuleOutput"))

(s/def :sf.substreams.rpc.v2.MapModuleOutput/name string?)


(s/def ::MapModuleOutput-spec (s/keys :opt-un [:sf.substreams.rpc.v2.MapModuleOutput/name ]))
(def MapModuleOutput-defaults {:name "" })

(defn cis->MapModuleOutput
  "CodedInputStream to MapModuleOutput"
  [is]
  (->> (tag-map MapModuleOutput-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:map-output (com.google.protobuf/ecis->Any is)]
               10 [:debug-info (ecis->OutputDebugInfo is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MapModuleOutput-record)))

(defn ecis->MapModuleOutput
  "Embedded CodedInputStream to MapModuleOutput"
  [is]
  (serdes.core/cis->embedded cis->MapModuleOutput is))

(defn new-MapModuleOutput
  "Creates a new instance from a map, similar to map->MapModuleOutput except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MapModuleOutput-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MapModuleOutput-spec init))))]}
  (-> (merge MapModuleOutput-defaults init)
      (cond-> (some? (get init :map-output)) (update :map-output com.google.protobuf/new-Any))
      (cond-> (some? (get init :debug-info)) (update :debug-info new-OutputDebugInfo))
      (map->MapModuleOutput-record)))

(defn pb->MapModuleOutput
  "Protobuf to MapModuleOutput"
  [input]
  (cis->MapModuleOutput (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MapModuleOutput-meta {:type "sf.substreams.rpc.v2.MapModuleOutput" :decoder pb->MapModuleOutput})

;-----------------------------------------------------------------------------
; BlockRange
;-----------------------------------------------------------------------------
(defrecord BlockRange-record [start-block end-block]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 2  {:optimize true} (:start-block this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:end-block this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.BlockRange"))

(s/def :sf.substreams.rpc.v2.BlockRange/start-block int?)
(s/def :sf.substreams.rpc.v2.BlockRange/end-block int?)
(s/def ::BlockRange-spec (s/keys :opt-un [:sf.substreams.rpc.v2.BlockRange/start-block :sf.substreams.rpc.v2.BlockRange/end-block ]))
(def BlockRange-defaults {:start-block 0 :end-block 0 })

(defn cis->BlockRange
  "CodedInputStream to BlockRange"
  [is]
  (->> (tag-map BlockRange-defaults
         (fn [tag index]
             (case index
               2 [:start-block (serdes.core/cis->UInt64 is)]
               3 [:end-block (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockRange-record)))

(defn ecis->BlockRange
  "Embedded CodedInputStream to BlockRange"
  [is]
  (serdes.core/cis->embedded cis->BlockRange is))

(defn new-BlockRange
  "Creates a new instance from a map, similar to map->BlockRange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockRange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockRange-spec init))))]}
  (-> (merge BlockRange-defaults init)
      (map->BlockRange-record)))

(defn pb->BlockRange
  "Protobuf to BlockRange"
  [input]
  (cis->BlockRange (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockRange-meta {:type "sf.substreams.rpc.v2.BlockRange" :decoder pb->BlockRange})

;-----------------------------------------------------------------------------
; StoreDelta
;-----------------------------------------------------------------------------
(defrecord StoreDelta-record [operation ordinal key old-value new-value]
  pb/Writer
  (serialize [this os]
    (write-StoreDelta-Operation 1  {:optimize true} (:operation this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:ordinal this) os)
    (serdes.core/write-String 3  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 4  {:optimize true} (:old-value this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:new-value this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.StoreDelta"))

(s/def :sf.substreams.rpc.v2.StoreDelta/operation (s/or :keyword keyword? :int int?))
(s/def :sf.substreams.rpc.v2.StoreDelta/ordinal int?)
(s/def :sf.substreams.rpc.v2.StoreDelta/key string?)
(s/def :sf.substreams.rpc.v2.StoreDelta/old-value bytes?)
(s/def :sf.substreams.rpc.v2.StoreDelta/new-value bytes?)
(s/def ::StoreDelta-spec (s/keys :opt-un [:sf.substreams.rpc.v2.StoreDelta/operation :sf.substreams.rpc.v2.StoreDelta/ordinal :sf.substreams.rpc.v2.StoreDelta/key :sf.substreams.rpc.v2.StoreDelta/old-value :sf.substreams.rpc.v2.StoreDelta/new-value ]))
(def StoreDelta-defaults {:operation StoreDelta-Operation-default :ordinal 0 :key "" :old-value (byte-array 0) :new-value (byte-array 0) })

(defn cis->StoreDelta
  "CodedInputStream to StoreDelta"
  [is]
  (->> (tag-map StoreDelta-defaults
         (fn [tag index]
             (case index
               1 [:operation (cis->StoreDelta-Operation is)]
               2 [:ordinal (serdes.core/cis->UInt64 is)]
               3 [:key (serdes.core/cis->String is)]
               4 [:old-value (serdes.core/cis->Bytes is)]
               5 [:new-value (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StoreDelta-record)))

(defn ecis->StoreDelta
  "Embedded CodedInputStream to StoreDelta"
  [is]
  (serdes.core/cis->embedded cis->StoreDelta is))

(defn new-StoreDelta
  "Creates a new instance from a map, similar to map->StoreDelta except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StoreDelta-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StoreDelta-spec init))))]}
  (-> (merge StoreDelta-defaults init)
      (map->StoreDelta-record)))

(defn pb->StoreDelta
  "Protobuf to StoreDelta"
  [input]
  (cis->StoreDelta (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StoreDelta-meta {:type "sf.substreams.rpc.v2.StoreDelta" :decoder pb->StoreDelta})

;-----------------------------------------------------------------------------
; OutputDebugInfo
;-----------------------------------------------------------------------------
(defrecord OutputDebugInfo-record [logs logs-truncated cached]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-String 1 (:logs this) os)
    (serdes.core/write-Bool 2  {:optimize true} (:logs-truncated this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:cached this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.OutputDebugInfo"))

(s/def :sf.substreams.rpc.v2.OutputDebugInfo/logs (s/every string?))
(s/def :sf.substreams.rpc.v2.OutputDebugInfo/logs-truncated boolean?)
(s/def :sf.substreams.rpc.v2.OutputDebugInfo/cached boolean?)
(s/def ::OutputDebugInfo-spec (s/keys :opt-un [:sf.substreams.rpc.v2.OutputDebugInfo/logs :sf.substreams.rpc.v2.OutputDebugInfo/logs-truncated :sf.substreams.rpc.v2.OutputDebugInfo/cached ]))
(def OutputDebugInfo-defaults {:logs [] :logs-truncated false :cached false })

(defn cis->OutputDebugInfo
  "CodedInputStream to OutputDebugInfo"
  [is]
  (->> (tag-map OutputDebugInfo-defaults
         (fn [tag index]
             (case index
               1 [:logs (serdes.complex/cis->repeated serdes.core/cis->String is)]
               2 [:logs-truncated (serdes.core/cis->Bool is)]
               3 [:cached (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->OutputDebugInfo-record)))

(defn ecis->OutputDebugInfo
  "Embedded CodedInputStream to OutputDebugInfo"
  [is]
  (serdes.core/cis->embedded cis->OutputDebugInfo is))

(defn new-OutputDebugInfo
  "Creates a new instance from a map, similar to map->OutputDebugInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OutputDebugInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OutputDebugInfo-spec init))))]}
  (-> (merge OutputDebugInfo-defaults init)
      (map->OutputDebugInfo-record)))

(defn pb->OutputDebugInfo
  "Protobuf to OutputDebugInfo"
  [input]
  (cis->OutputDebugInfo (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OutputDebugInfo-meta {:type "sf.substreams.rpc.v2.OutputDebugInfo" :decoder pb->OutputDebugInfo})

;-----------------------------------------------------------------------------
; InitialSnapshotComplete
;-----------------------------------------------------------------------------
(defrecord InitialSnapshotComplete-record [cursor]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:cursor this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.InitialSnapshotComplete"))

(s/def :sf.substreams.rpc.v2.InitialSnapshotComplete/cursor string?)
(s/def ::InitialSnapshotComplete-spec (s/keys :opt-un [:sf.substreams.rpc.v2.InitialSnapshotComplete/cursor ]))
(def InitialSnapshotComplete-defaults {:cursor "" })

(defn cis->InitialSnapshotComplete
  "CodedInputStream to InitialSnapshotComplete"
  [is]
  (->> (tag-map InitialSnapshotComplete-defaults
         (fn [tag index]
             (case index
               1 [:cursor (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->InitialSnapshotComplete-record)))

(defn ecis->InitialSnapshotComplete
  "Embedded CodedInputStream to InitialSnapshotComplete"
  [is]
  (serdes.core/cis->embedded cis->InitialSnapshotComplete is))

(defn new-InitialSnapshotComplete
  "Creates a new instance from a map, similar to map->InitialSnapshotComplete except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::InitialSnapshotComplete-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::InitialSnapshotComplete-spec init))))]}
  (-> (merge InitialSnapshotComplete-defaults init)
      (map->InitialSnapshotComplete-record)))

(defn pb->InitialSnapshotComplete
  "Protobuf to InitialSnapshotComplete"
  [input]
  (cis->InitialSnapshotComplete (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record InitialSnapshotComplete-meta {:type "sf.substreams.rpc.v2.InitialSnapshotComplete" :decoder pb->InitialSnapshotComplete})

;-----------------------------------------------------------------------------
; InitialSnapshotData
;-----------------------------------------------------------------------------
(defrecord InitialSnapshotData-record [module-name deltas sent-keys total-keys]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:module-name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:deltas this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:sent-keys this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:total-keys this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.InitialSnapshotData"))

(s/def :sf.substreams.rpc.v2.InitialSnapshotData/module-name string?)

(s/def :sf.substreams.rpc.v2.InitialSnapshotData/sent-keys int?)
(s/def :sf.substreams.rpc.v2.InitialSnapshotData/total-keys int?)
(s/def ::InitialSnapshotData-spec (s/keys :opt-un [:sf.substreams.rpc.v2.InitialSnapshotData/module-name :sf.substreams.rpc.v2.InitialSnapshotData/sent-keys :sf.substreams.rpc.v2.InitialSnapshotData/total-keys ]))
(def InitialSnapshotData-defaults {:module-name "" :deltas [] :sent-keys 0 :total-keys 0 })

(defn cis->InitialSnapshotData
  "CodedInputStream to InitialSnapshotData"
  [is]
  (->> (tag-map InitialSnapshotData-defaults
         (fn [tag index]
             (case index
               1 [:module-name (serdes.core/cis->String is)]
               2 [:deltas (serdes.complex/cis->repeated ecis->StoreDelta is)]
               4 [:sent-keys (serdes.core/cis->UInt64 is)]
               3 [:total-keys (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->InitialSnapshotData-record)))

(defn ecis->InitialSnapshotData
  "Embedded CodedInputStream to InitialSnapshotData"
  [is]
  (serdes.core/cis->embedded cis->InitialSnapshotData is))

(defn new-InitialSnapshotData
  "Creates a new instance from a map, similar to map->InitialSnapshotData except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::InitialSnapshotData-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::InitialSnapshotData-spec init))))]}
  (-> (merge InitialSnapshotData-defaults init)
      (cond-> (some? (get init :deltas)) (update :deltas #(map new-StoreDelta %)))
      (map->InitialSnapshotData-record)))

(defn pb->InitialSnapshotData
  "Protobuf to InitialSnapshotData"
  [input]
  (cis->InitialSnapshotData (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record InitialSnapshotData-meta {:type "sf.substreams.rpc.v2.InitialSnapshotData" :decoder pb->InitialSnapshotData})

;-----------------------------------------------------------------------------
; Response
;-----------------------------------------------------------------------------
(defrecord Response-record [message]
  pb/Writer
  (serialize [this os]
    (write-Response-message  (:message this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.Response"))

(s/def ::Response-spec (s/keys :opt-un []))
(def Response-defaults {})

(defn cis->Response
  "CodedInputStream to Response"
  [is]
  (->> (tag-map Response-defaults
         (fn [tag index]
             (case index
               1 [:message {:session (ecis->SessionInit is)}]
               2 [:message {:progress (ecis->ModulesProgress is)}]
               3 [:message {:block-scoped-data (ecis->BlockScopedData is)}]
               4 [:message {:block-undo-signal (ecis->BlockUndoSignal is)}]
               5 [:message {:fatal-error (ecis->Error is)}]
               10 [:message {:debug-snapshot-data (ecis->InitialSnapshotData is)}]
               11 [:message {:debug-snapshot-complete (ecis->InitialSnapshotComplete is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Response-record)))

(defn ecis->Response
  "Embedded CodedInputStream to Response"
  [is]
  (serdes.core/cis->embedded cis->Response is))

(defn new-Response
  "Creates a new instance from a map, similar to map->Response except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Response-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Response-spec init))))]}
  (-> (merge Response-defaults init)
      (convert-Response-message)
      (map->Response-record)))

(defn pb->Response
  "Protobuf to Response"
  [input]
  (cis->Response (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Response-meta {:type "sf.substreams.rpc.v2.Response" :decoder pb->Response})

;-----------------------------------------------------------------------------
; StoreModuleOutput
;-----------------------------------------------------------------------------
(defrecord StoreModuleOutput-record [name debug-store-deltas debug-info]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:debug-store-deltas this) os)
    (serdes.core/write-embedded 10 (:debug-info this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.StoreModuleOutput"))

(s/def :sf.substreams.rpc.v2.StoreModuleOutput/name string?)


(s/def ::StoreModuleOutput-spec (s/keys :opt-un [:sf.substreams.rpc.v2.StoreModuleOutput/name ]))
(def StoreModuleOutput-defaults {:name "" :debug-store-deltas [] })

(defn cis->StoreModuleOutput
  "CodedInputStream to StoreModuleOutput"
  [is]
  (->> (tag-map StoreModuleOutput-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:debug-store-deltas (serdes.complex/cis->repeated ecis->StoreDelta is)]
               10 [:debug-info (ecis->OutputDebugInfo is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StoreModuleOutput-record)))

(defn ecis->StoreModuleOutput
  "Embedded CodedInputStream to StoreModuleOutput"
  [is]
  (serdes.core/cis->embedded cis->StoreModuleOutput is))

(defn new-StoreModuleOutput
  "Creates a new instance from a map, similar to map->StoreModuleOutput except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StoreModuleOutput-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StoreModuleOutput-spec init))))]}
  (-> (merge StoreModuleOutput-defaults init)
      (cond-> (some? (get init :debug-store-deltas)) (update :debug-store-deltas #(map new-StoreDelta %)))
      (cond-> (some? (get init :debug-info)) (update :debug-info new-OutputDebugInfo))
      (map->StoreModuleOutput-record)))

(defn pb->StoreModuleOutput
  "Protobuf to StoreModuleOutput"
  [input]
  (cis->StoreModuleOutput (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StoreModuleOutput-meta {:type "sf.substreams.rpc.v2.StoreModuleOutput" :decoder pb->StoreModuleOutput})

;-----------------------------------------------------------------------------
; ProcessedBytes
;-----------------------------------------------------------------------------
(defrecord ProcessedBytes-record [total-bytes-read total-bytes-written]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:total-bytes-read this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:total-bytes-written this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.ProcessedBytes"))

(s/def :sf.substreams.rpc.v2.ProcessedBytes/total-bytes-read int?)
(s/def :sf.substreams.rpc.v2.ProcessedBytes/total-bytes-written int?)
(s/def ::ProcessedBytes-spec (s/keys :opt-un [:sf.substreams.rpc.v2.ProcessedBytes/total-bytes-read :sf.substreams.rpc.v2.ProcessedBytes/total-bytes-written ]))
(def ProcessedBytes-defaults {:total-bytes-read 0 :total-bytes-written 0 })

(defn cis->ProcessedBytes
  "CodedInputStream to ProcessedBytes"
  [is]
  (->> (tag-map ProcessedBytes-defaults
         (fn [tag index]
             (case index
               1 [:total-bytes-read (serdes.core/cis->UInt64 is)]
               2 [:total-bytes-written (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ProcessedBytes-record)))

(defn ecis->ProcessedBytes
  "Embedded CodedInputStream to ProcessedBytes"
  [is]
  (serdes.core/cis->embedded cis->ProcessedBytes is))

(defn new-ProcessedBytes
  "Creates a new instance from a map, similar to map->ProcessedBytes except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ProcessedBytes-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ProcessedBytes-spec init))))]}
  (-> (merge ProcessedBytes-defaults init)
      (map->ProcessedBytes-record)))

(defn pb->ProcessedBytes
  "Protobuf to ProcessedBytes"
  [input]
  (cis->ProcessedBytes (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ProcessedBytes-meta {:type "sf.substreams.rpc.v2.ProcessedBytes" :decoder pb->ProcessedBytes})

;-----------------------------------------------------------------------------
; ModuleStats
;-----------------------------------------------------------------------------
(defrecord ModuleStats-record [total-store-merging-time-ms total-store-write-count total-processed-block-count total-store-read-count name store-currently-merging total-processing-time-ms external-call-metrics total-store-operation-time-ms total-store-deleteprefix-count store-size-bytes highest-contiguous-block]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 13  {:optimize true} (:total-store-merging-time-ms this) os)
    (serdes.core/write-UInt64 10  {:optimize true} (:total-store-write-count this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:total-processed-block-count this) os)
    (serdes.core/write-UInt64 6  {:optimize true} (:total-store-read-count this) os)
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-Bool 14  {:optimize true} (:store-currently-merging this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:total-processing-time-ms this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:external-call-metrics this) os)
    (serdes.core/write-UInt64 5  {:optimize true} (:total-store-operation-time-ms this) os)
    (serdes.core/write-UInt64 11  {:optimize true} (:total-store-deleteprefix-count this) os)
    (serdes.core/write-UInt64 12  {:optimize true} (:store-size-bytes this) os)
    (serdes.core/write-UInt64 15  {:optimize true} (:highest-contiguous-block this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.ModuleStats"))

(s/def :sf.substreams.rpc.v2.ModuleStats/total-store-merging-time-ms int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/total-store-write-count int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/total-processed-block-count int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/total-store-read-count int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/name string?)
(s/def :sf.substreams.rpc.v2.ModuleStats/store-currently-merging boolean?)
(s/def :sf.substreams.rpc.v2.ModuleStats/total-processing-time-ms int?)

(s/def :sf.substreams.rpc.v2.ModuleStats/total-store-operation-time-ms int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/total-store-deleteprefix-count int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/store-size-bytes int?)
(s/def :sf.substreams.rpc.v2.ModuleStats/highest-contiguous-block int?)
(s/def ::ModuleStats-spec (s/keys :opt-un [:sf.substreams.rpc.v2.ModuleStats/total-store-merging-time-ms :sf.substreams.rpc.v2.ModuleStats/total-store-write-count :sf.substreams.rpc.v2.ModuleStats/total-processed-block-count :sf.substreams.rpc.v2.ModuleStats/total-store-read-count :sf.substreams.rpc.v2.ModuleStats/name :sf.substreams.rpc.v2.ModuleStats/store-currently-merging :sf.substreams.rpc.v2.ModuleStats/total-processing-time-ms :sf.substreams.rpc.v2.ModuleStats/total-store-operation-time-ms :sf.substreams.rpc.v2.ModuleStats/total-store-deleteprefix-count :sf.substreams.rpc.v2.ModuleStats/store-size-bytes :sf.substreams.rpc.v2.ModuleStats/highest-contiguous-block ]))
(def ModuleStats-defaults {:total-store-merging-time-ms 0 :total-store-write-count 0 :total-processed-block-count 0 :total-store-read-count 0 :name "" :store-currently-merging false :total-processing-time-ms 0 :external-call-metrics [] :total-store-operation-time-ms 0 :total-store-deleteprefix-count 0 :store-size-bytes 0 :highest-contiguous-block 0 })

(defn cis->ModuleStats
  "CodedInputStream to ModuleStats"
  [is]
  (->> (tag-map ModuleStats-defaults
         (fn [tag index]
             (case index
               13 [:total-store-merging-time-ms (serdes.core/cis->UInt64 is)]
               10 [:total-store-write-count (serdes.core/cis->UInt64 is)]
               2 [:total-processed-block-count (serdes.core/cis->UInt64 is)]
               6 [:total-store-read-count (serdes.core/cis->UInt64 is)]
               1 [:name (serdes.core/cis->String is)]
               14 [:store-currently-merging (serdes.core/cis->Bool is)]
               3 [:total-processing-time-ms (serdes.core/cis->UInt64 is)]
               4 [:external-call-metrics (serdes.complex/cis->repeated ecis->ExternalCallMetric is)]
               5 [:total-store-operation-time-ms (serdes.core/cis->UInt64 is)]
               11 [:total-store-deleteprefix-count (serdes.core/cis->UInt64 is)]
               12 [:store-size-bytes (serdes.core/cis->UInt64 is)]
               15 [:highest-contiguous-block (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ModuleStats-record)))

(defn ecis->ModuleStats
  "Embedded CodedInputStream to ModuleStats"
  [is]
  (serdes.core/cis->embedded cis->ModuleStats is))

(defn new-ModuleStats
  "Creates a new instance from a map, similar to map->ModuleStats except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ModuleStats-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ModuleStats-spec init))))]}
  (-> (merge ModuleStats-defaults init)
      (cond-> (some? (get init :external-call-metrics)) (update :external-call-metrics #(map new-ExternalCallMetric %)))
      (map->ModuleStats-record)))

(defn pb->ModuleStats
  "Protobuf to ModuleStats"
  [input]
  (cis->ModuleStats (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ModuleStats-meta {:type "sf.substreams.rpc.v2.ModuleStats" :decoder pb->ModuleStats})

;-----------------------------------------------------------------------------
; BlockScopedData
;-----------------------------------------------------------------------------
(defrecord BlockScopedData-record [output clock cursor final-block-height debug-map-outputs debug-store-outputs]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:output this) os)
    (serdes.core/write-embedded 2 (:clock this) os)
    (serdes.core/write-String 3  {:optimize true} (:cursor this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:final-block-height this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 10 (:debug-map-outputs this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 11 (:debug-store-outputs this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.BlockScopedData"))

(s/def :sf.substreams.rpc.v2.BlockScopedData/cursor string?)
(s/def :sf.substreams.rpc.v2.BlockScopedData/final-block-height int?)


(s/def ::BlockScopedData-spec (s/keys :opt-un [:sf.substreams.rpc.v2.BlockScopedData/cursor :sf.substreams.rpc.v2.BlockScopedData/final-block-height ]))
(def BlockScopedData-defaults {:cursor "" :final-block-height 0 :debug-map-outputs [] :debug-store-outputs [] })

(defn cis->BlockScopedData
  "CodedInputStream to BlockScopedData"
  [is]
  (->> (tag-map BlockScopedData-defaults
         (fn [tag index]
             (case index
               1 [:output (ecis->MapModuleOutput is)]
               2 [:clock (sf.substreams.v1/ecis->Clock is)]
               3 [:cursor (serdes.core/cis->String is)]
               4 [:final-block-height (serdes.core/cis->UInt64 is)]
               10 [:debug-map-outputs (serdes.complex/cis->repeated ecis->MapModuleOutput is)]
               11 [:debug-store-outputs (serdes.complex/cis->repeated ecis->StoreModuleOutput is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockScopedData-record)))

(defn ecis->BlockScopedData
  "Embedded CodedInputStream to BlockScopedData"
  [is]
  (serdes.core/cis->embedded cis->BlockScopedData is))

(defn new-BlockScopedData
  "Creates a new instance from a map, similar to map->BlockScopedData except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockScopedData-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockScopedData-spec init))))]}
  (-> (merge BlockScopedData-defaults init)
      (cond-> (some? (get init :output)) (update :output new-MapModuleOutput))
      (cond-> (some? (get init :clock)) (update :clock sf.substreams.v1/new-Clock))
      (cond-> (some? (get init :debug-map-outputs)) (update :debug-map-outputs #(map new-MapModuleOutput %)))
      (cond-> (some? (get init :debug-store-outputs)) (update :debug-store-outputs #(map new-StoreModuleOutput %)))
      (map->BlockScopedData-record)))

(defn pb->BlockScopedData
  "Protobuf to BlockScopedData"
  [input]
  (cis->BlockScopedData (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockScopedData-meta {:type "sf.substreams.rpc.v2.BlockScopedData" :decoder pb->BlockScopedData})

;-----------------------------------------------------------------------------
; SessionInit
;-----------------------------------------------------------------------------
(defrecord SessionInit-record [trace-id resolved-start-block linear-handoff-block max-parallel-workers]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:trace-id this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:resolved-start-block this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:linear-handoff-block this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:max-parallel-workers this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.SessionInit"))

(s/def :sf.substreams.rpc.v2.SessionInit/trace-id string?)
(s/def :sf.substreams.rpc.v2.SessionInit/resolved-start-block int?)
(s/def :sf.substreams.rpc.v2.SessionInit/linear-handoff-block int?)
(s/def :sf.substreams.rpc.v2.SessionInit/max-parallel-workers int?)
(s/def ::SessionInit-spec (s/keys :opt-un [:sf.substreams.rpc.v2.SessionInit/trace-id :sf.substreams.rpc.v2.SessionInit/resolved-start-block :sf.substreams.rpc.v2.SessionInit/linear-handoff-block :sf.substreams.rpc.v2.SessionInit/max-parallel-workers ]))
(def SessionInit-defaults {:trace-id "" :resolved-start-block 0 :linear-handoff-block 0 :max-parallel-workers 0 })

(defn cis->SessionInit
  "CodedInputStream to SessionInit"
  [is]
  (->> (tag-map SessionInit-defaults
         (fn [tag index]
             (case index
               1 [:trace-id (serdes.core/cis->String is)]
               2 [:resolved-start-block (serdes.core/cis->UInt64 is)]
               3 [:linear-handoff-block (serdes.core/cis->UInt64 is)]
               4 [:max-parallel-workers (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->SessionInit-record)))

(defn ecis->SessionInit
  "Embedded CodedInputStream to SessionInit"
  [is]
  (serdes.core/cis->embedded cis->SessionInit is))

(defn new-SessionInit
  "Creates a new instance from a map, similar to map->SessionInit except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SessionInit-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SessionInit-spec init))))]}
  (-> (merge SessionInit-defaults init)
      (map->SessionInit-record)))

(defn pb->SessionInit
  "Protobuf to SessionInit"
  [input]
  (cis->SessionInit (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SessionInit-meta {:type "sf.substreams.rpc.v2.SessionInit" :decoder pb->SessionInit})

;-----------------------------------------------------------------------------
; ExternalCallMetric
;-----------------------------------------------------------------------------
(defrecord ExternalCallMetric-record [name count time-ms]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:count this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:time-ms this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.ExternalCallMetric"))

(s/def :sf.substreams.rpc.v2.ExternalCallMetric/name string?)
(s/def :sf.substreams.rpc.v2.ExternalCallMetric/count int?)
(s/def :sf.substreams.rpc.v2.ExternalCallMetric/time-ms int?)
(s/def ::ExternalCallMetric-spec (s/keys :opt-un [:sf.substreams.rpc.v2.ExternalCallMetric/name :sf.substreams.rpc.v2.ExternalCallMetric/count :sf.substreams.rpc.v2.ExternalCallMetric/time-ms ]))
(def ExternalCallMetric-defaults {:name "" :count 0 :time-ms 0 })

(defn cis->ExternalCallMetric
  "CodedInputStream to ExternalCallMetric"
  [is]
  (->> (tag-map ExternalCallMetric-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]
               2 [:count (serdes.core/cis->UInt64 is)]
               3 [:time-ms (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ExternalCallMetric-record)))

(defn ecis->ExternalCallMetric
  "Embedded CodedInputStream to ExternalCallMetric"
  [is]
  (serdes.core/cis->embedded cis->ExternalCallMetric is))

(defn new-ExternalCallMetric
  "Creates a new instance from a map, similar to map->ExternalCallMetric except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ExternalCallMetric-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ExternalCallMetric-spec init))))]}
  (-> (merge ExternalCallMetric-defaults init)
      (map->ExternalCallMetric-record)))

(defn pb->ExternalCallMetric
  "Protobuf to ExternalCallMetric"
  [input]
  (cis->ExternalCallMetric (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ExternalCallMetric-meta {:type "sf.substreams.rpc.v2.ExternalCallMetric" :decoder pb->ExternalCallMetric})

;-----------------------------------------------------------------------------
; Error
;-----------------------------------------------------------------------------
(defrecord Error-record [module reason logs logs-truncated]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:module this) os)
    (serdes.core/write-String 2  {:optimize true} (:reason this) os)
    (serdes.complex/write-repeated serdes.core/write-String 3 (:logs this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:logs-truncated this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.Error"))

(s/def :sf.substreams.rpc.v2.Error/module string?)
(s/def :sf.substreams.rpc.v2.Error/reason string?)
(s/def :sf.substreams.rpc.v2.Error/logs (s/every string?))
(s/def :sf.substreams.rpc.v2.Error/logs-truncated boolean?)
(s/def ::Error-spec (s/keys :opt-un [:sf.substreams.rpc.v2.Error/module :sf.substreams.rpc.v2.Error/reason :sf.substreams.rpc.v2.Error/logs :sf.substreams.rpc.v2.Error/logs-truncated ]))
(def Error-defaults {:module "" :reason "" :logs [] :logs-truncated false })

(defn cis->Error
  "CodedInputStream to Error"
  [is]
  (->> (tag-map Error-defaults
         (fn [tag index]
             (case index
               1 [:module (serdes.core/cis->String is)]
               2 [:reason (serdes.core/cis->String is)]
               3 [:logs (serdes.complex/cis->repeated serdes.core/cis->String is)]
               4 [:logs-truncated (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Error-record)))

(defn ecis->Error
  "Embedded CodedInputStream to Error"
  [is]
  (serdes.core/cis->embedded cis->Error is))

(defn new-Error
  "Creates a new instance from a map, similar to map->Error except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Error-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Error-spec init))))]}
  (-> (merge Error-defaults init)
      (map->Error-record)))

(defn pb->Error
  "Protobuf to Error"
  [input]
  (cis->Error (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Error-meta {:type "sf.substreams.rpc.v2.Error" :decoder pb->Error})

;-----------------------------------------------------------------------------
; Job
;-----------------------------------------------------------------------------
(defrecord Job-record [stage start-block stop-block processed-blocks duration-ms]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:stage this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:start-block this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:stop-block this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:processed-blocks this) os)
    (serdes.core/write-UInt64 5  {:optimize true} (:duration-ms this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.Job"))

(s/def :sf.substreams.rpc.v2.Job/stage int?)
(s/def :sf.substreams.rpc.v2.Job/start-block int?)
(s/def :sf.substreams.rpc.v2.Job/stop-block int?)
(s/def :sf.substreams.rpc.v2.Job/processed-blocks int?)
(s/def :sf.substreams.rpc.v2.Job/duration-ms int?)
(s/def ::Job-spec (s/keys :opt-un [:sf.substreams.rpc.v2.Job/stage :sf.substreams.rpc.v2.Job/start-block :sf.substreams.rpc.v2.Job/stop-block :sf.substreams.rpc.v2.Job/processed-blocks :sf.substreams.rpc.v2.Job/duration-ms ]))
(def Job-defaults {:stage 0 :start-block 0 :stop-block 0 :processed-blocks 0 :duration-ms 0 })

(defn cis->Job
  "CodedInputStream to Job"
  [is]
  (->> (tag-map Job-defaults
         (fn [tag index]
             (case index
               1 [:stage (serdes.core/cis->UInt32 is)]
               2 [:start-block (serdes.core/cis->UInt64 is)]
               3 [:stop-block (serdes.core/cis->UInt64 is)]
               4 [:processed-blocks (serdes.core/cis->UInt64 is)]
               5 [:duration-ms (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Job-record)))

(defn ecis->Job
  "Embedded CodedInputStream to Job"
  [is]
  (serdes.core/cis->embedded cis->Job is))

(defn new-Job
  "Creates a new instance from a map, similar to map->Job except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Job-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Job-spec init))))]}
  (-> (merge Job-defaults init)
      (map->Job-record)))

(defn pb->Job
  "Protobuf to Job"
  [input]
  (cis->Job (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Job-meta {:type "sf.substreams.rpc.v2.Job" :decoder pb->Job})

;-----------------------------------------------------------------------------
; Stage
;-----------------------------------------------------------------------------
(defrecord Stage-record [modules completed-ranges]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-String 1 (:modules this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:completed-ranges this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.Stage"))

(s/def :sf.substreams.rpc.v2.Stage/modules (s/every string?))

(s/def ::Stage-spec (s/keys :opt-un [:sf.substreams.rpc.v2.Stage/modules ]))
(def Stage-defaults {:modules [] :completed-ranges [] })

(defn cis->Stage
  "CodedInputStream to Stage"
  [is]
  (->> (tag-map Stage-defaults
         (fn [tag index]
             (case index
               1 [:modules (serdes.complex/cis->repeated serdes.core/cis->String is)]
               2 [:completed-ranges (serdes.complex/cis->repeated ecis->BlockRange is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Stage-record)))

(defn ecis->Stage
  "Embedded CodedInputStream to Stage"
  [is]
  (serdes.core/cis->embedded cis->Stage is))

(defn new-Stage
  "Creates a new instance from a map, similar to map->Stage except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Stage-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Stage-spec init))))]}
  (-> (merge Stage-defaults init)
      (cond-> (some? (get init :completed-ranges)) (update :completed-ranges #(map new-BlockRange %)))
      (map->Stage-record)))

(defn pb->Stage
  "Protobuf to Stage"
  [input]
  (cis->Stage (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Stage-meta {:type "sf.substreams.rpc.v2.Stage" :decoder pb->Stage})

;-----------------------------------------------------------------------------
; BlockUndoSignal
;-----------------------------------------------------------------------------
(defrecord BlockUndoSignal-record [last-valid-block last-valid-cursor]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:last-valid-block this) os)
    (serdes.core/write-String 2  {:optimize true} (:last-valid-cursor this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.substreams.rpc.v2.BlockUndoSignal"))

(s/def :sf.substreams.rpc.v2.BlockUndoSignal/last-valid-cursor string?)
(s/def ::BlockUndoSignal-spec (s/keys :opt-un [:sf.substreams.rpc.v2.BlockUndoSignal/last-valid-cursor ]))
(def BlockUndoSignal-defaults {:last-valid-cursor "" })

(defn cis->BlockUndoSignal
  "CodedInputStream to BlockUndoSignal"
  [is]
  (->> (tag-map BlockUndoSignal-defaults
         (fn [tag index]
             (case index
               1 [:last-valid-block (sf.substreams.v1/ecis->BlockRef is)]
               2 [:last-valid-cursor (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockUndoSignal-record)))

(defn ecis->BlockUndoSignal
  "Embedded CodedInputStream to BlockUndoSignal"
  [is]
  (serdes.core/cis->embedded cis->BlockUndoSignal is))

(defn new-BlockUndoSignal
  "Creates a new instance from a map, similar to map->BlockUndoSignal except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockUndoSignal-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockUndoSignal-spec init))))]}
  (-> (merge BlockUndoSignal-defaults init)
      (cond-> (some? (get init :last-valid-block)) (update :last-valid-block sf.substreams.v1/new-BlockRef))
      (map->BlockUndoSignal-record)))

(defn pb->BlockUndoSignal
  "Protobuf to BlockUndoSignal"
  [input]
  (cis->BlockUndoSignal (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockUndoSignal-meta {:type "sf.substreams.rpc.v2.BlockUndoSignal" :decoder pb->BlockUndoSignal})

