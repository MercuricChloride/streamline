;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package sf.ethereum.type.v2
;;;----------------------------------------------------------------------------------
(ns sf.ethereum.type.v2
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Uint64NestedArray)
(declare ecis->Uint64NestedArray)
(declare new-Uint64NestedArray)
(declare cis->BlockRef)
(declare ecis->BlockRef)
(declare new-BlockRef)
(declare cis->TransactionTraceWithBlockRef)
(declare ecis->TransactionTraceWithBlockRef)
(declare new-TransactionTraceWithBlockRef)
(declare cis->GasChange)
(declare ecis->GasChange)
(declare new-GasChange)
(declare cis->StorageChange)
(declare ecis->StorageChange)
(declare new-StorageChange)
(declare cis->Log)
(declare ecis->Log)
(declare new-Log)
(declare cis->AccountCreation)
(declare ecis->AccountCreation)
(declare new-AccountCreation)
(declare cis->CodeChange)
(declare ecis->CodeChange)
(declare new-CodeChange)
(declare cis->TransactionTrace)
(declare ecis->TransactionTrace)
(declare new-TransactionTrace)
(declare cis->TransactionReceipt)
(declare ecis->TransactionReceipt)
(declare new-TransactionReceipt)
(declare cis->TransactionRefs)
(declare ecis->TransactionRefs)
(declare new-TransactionRefs)
(declare cis->Uint64Array)
(declare ecis->Uint64Array)
(declare new-Uint64Array)
(declare cis->Block)
(declare ecis->Block)
(declare new-Block)
(declare cis->HeaderOnlyBlock)
(declare ecis->HeaderOnlyBlock)
(declare new-HeaderOnlyBlock)
(declare cis->BlockHeader)
(declare ecis->BlockHeader)
(declare new-BlockHeader)
(declare cis->BigInt)
(declare ecis->BigInt)
(declare new-BigInt)
(declare cis->BalanceChange)
(declare ecis->BalanceChange)
(declare new-BalanceChange)
(declare cis->AccessTuple)
(declare ecis->AccessTuple)
(declare new-AccessTuple)
(declare cis->BlockWithRefs)
(declare ecis->BlockWithRefs)
(declare new-BlockWithRefs)
(declare cis->Call)
(declare ecis->Call)
(declare new-Call)
(declare cis->Call-KeccakPreimagesEntry)
(declare ecis->Call-KeccakPreimagesEntry)
(declare new-Call-KeccakPreimagesEntry)
(declare cis->NonceChange)
(declare ecis->NonceChange)
(declare new-NonceChange)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; TransactionTraceStatus
;-----------------------------------------------------------------------------
(def TransactionTraceStatus-default :unknown)

(def TransactionTraceStatus-val2label {
  0 :unknown
  1 :succeeded
  2 :failed
  3 :reverted})

(def TransactionTraceStatus-label2val (set/map-invert TransactionTraceStatus-val2label))

(defn cis->TransactionTraceStatus [is]
  (let [val (serdes.core/cis->Enum is)]
    (get TransactionTraceStatus-val2label val val)))

(defn- get-TransactionTraceStatus [value]
  {:pre [(or (int? value) (contains? TransactionTraceStatus-label2val value))]}
  (get TransactionTraceStatus-label2val value value))

(defn write-TransactionTraceStatus
  ([tag value os] (write-TransactionTraceStatus tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-TransactionTraceStatus value) os)))

;-----------------------------------------------------------------------------
; CallType
;-----------------------------------------------------------------------------
(def CallType-default :unspecified)

(def CallType-val2label {
  0 :unspecified
  1 :call
  2 :callcode
  3 :delegate
  4 :static
  5 :create})

(def CallType-label2val (set/map-invert CallType-val2label))

(defn cis->CallType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get CallType-val2label val val)))

(defn- get-CallType [value]
  {:pre [(or (int? value) (contains? CallType-label2val value))]}
  (get CallType-label2val value value))

(defn write-CallType
  ([tag value os] (write-CallType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-CallType value) os)))

;-----------------------------------------------------------------------------
; TransactionTrace-Type
;-----------------------------------------------------------------------------
(def TransactionTrace-Type-default :trx-type-legacy)

(def TransactionTrace-Type-val2label {
  0 :trx-type-legacy
  1 :trx-type-access-list
  2 :trx-type-dynamic-fee})

(def TransactionTrace-Type-label2val (set/map-invert TransactionTrace-Type-val2label))

(defn cis->TransactionTrace-Type [is]
  (let [val (serdes.core/cis->Enum is)]
    (get TransactionTrace-Type-val2label val val)))

(defn- get-TransactionTrace-Type [value]
  {:pre [(or (int? value) (contains? TransactionTrace-Type-label2val value))]}
  (get TransactionTrace-Type-label2val value value))

(defn write-TransactionTrace-Type
  ([tag value os] (write-TransactionTrace-Type tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-TransactionTrace-Type value) os)))

;-----------------------------------------------------------------------------
; BalanceChange-Reason
;-----------------------------------------------------------------------------
(def BalanceChange-Reason-default :reason-gas-refund)

(def BalanceChange-Reason-val2label {
  9 :reason-gas-refund
  3 :reason-dao-refund-contract
  4 :reason-dao-adjust-balance
  8 :reason-reward-transaction-fee
  14 :reason-reward-fee-reset
  15 :reason-burn
  7 :reason-gas-buy
  5 :reason-transfer
  12 :reason-call-balance-override
  13 :reason-suicide-withdraw
  6 :reason-genesis-balance
  1 :reason-reward-mine-uncle
  0 :reason-unknown
  11 :reason-suicide-refund
  2 :reason-reward-mine-block
  16 :reason-withdrawal
  10 :reason-touch-account})

(def BalanceChange-Reason-label2val (set/map-invert BalanceChange-Reason-val2label))

(defn cis->BalanceChange-Reason [is]
  (let [val (serdes.core/cis->Enum is)]
    (get BalanceChange-Reason-val2label val val)))

(defn- get-BalanceChange-Reason [value]
  {:pre [(or (int? value) (contains? BalanceChange-Reason-label2val value))]}
  (get BalanceChange-Reason-label2val value value))

(defn write-BalanceChange-Reason
  ([tag value os] (write-BalanceChange-Reason tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-BalanceChange-Reason value) os)))

;-----------------------------------------------------------------------------
; GasChange-Reason
;-----------------------------------------------------------------------------
(def GasChange-Reason-default :reason-event-log)

(def GasChange-Reason-val2label {
  9 :reason-event-log
  3 :reason-call-data-copy
  4 :reason-code-copy
  8 :reason-delegate-call
  14 :reason-refund-after-execution
  20 :reason-state-cold-access
  19 :reason-static-call
  17 :reason-revert
  15 :reason-return
  7 :reason-contract-creation2
  5 :reason-code-storage
  18 :reason-self-destruct
  12 :reason-intrinsic-gas
  13 :reason-precompiled-contract
  6 :reason-contract-creation
  1 :reason-call
  0 :reason-unknown
  11 :reason-failed-execution
  2 :reason-call-code
  16 :reason-return-data-copy
  10 :reason-ext-code-copy})

(def GasChange-Reason-label2val (set/map-invert GasChange-Reason-val2label))

(defn cis->GasChange-Reason [is]
  (let [val (serdes.core/cis->Enum is)]
    (get GasChange-Reason-val2label val val)))

(defn- get-GasChange-Reason [value]
  {:pre [(or (int? value) (contains? GasChange-Reason-label2val value))]}
  (get GasChange-Reason-label2val value value))

(defn write-GasChange-Reason
  ([tag value os] (write-GasChange-Reason tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-GasChange-Reason value) os)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Uint64NestedArray
;-----------------------------------------------------------------------------
(defrecord Uint64NestedArray-record [val]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:val this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.Uint64NestedArray"))

(s/def ::Uint64NestedArray-spec (s/keys :opt-un []))
(def Uint64NestedArray-defaults {:val [] })

(defn cis->Uint64NestedArray
  "CodedInputStream to Uint64NestedArray"
  [is]
  (->> (tag-map Uint64NestedArray-defaults
         (fn [tag index]
             (case index
               1 [:val (serdes.complex/cis->repeated ecis->Uint64Array is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Uint64NestedArray-record)))

(defn ecis->Uint64NestedArray
  "Embedded CodedInputStream to Uint64NestedArray"
  [is]
  (serdes.core/cis->embedded cis->Uint64NestedArray is))

(defn new-Uint64NestedArray
  "Creates a new instance from a map, similar to map->Uint64NestedArray except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Uint64NestedArray-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Uint64NestedArray-spec init))))]}
  (-> (merge Uint64NestedArray-defaults init)
      (cond-> (some? (get init :val)) (update :val #(map new-Uint64Array %)))
      (map->Uint64NestedArray-record)))

(defn pb->Uint64NestedArray
  "Protobuf to Uint64NestedArray"
  [input]
  (cis->Uint64NestedArray (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Uint64NestedArray-meta {:type "sf.ethereum.type.v2.Uint64NestedArray" :decoder pb->Uint64NestedArray})

;-----------------------------------------------------------------------------
; BlockRef
;-----------------------------------------------------------------------------
(defrecord BlockRef-record [hash number]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:hash this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:number this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.BlockRef"))

(s/def :sf.ethereum.type.v2.BlockRef/hash bytes?)
(s/def :sf.ethereum.type.v2.BlockRef/number int?)
(s/def ::BlockRef-spec (s/keys :opt-un [:sf.ethereum.type.v2.BlockRef/hash :sf.ethereum.type.v2.BlockRef/number ]))
(def BlockRef-defaults {:hash (byte-array 0) :number 0 })

(defn cis->BlockRef
  "CodedInputStream to BlockRef"
  [is]
  (->> (tag-map BlockRef-defaults
         (fn [tag index]
             (case index
               1 [:hash (serdes.core/cis->Bytes is)]
               2 [:number (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockRef-record)))

(defn ecis->BlockRef
  "Embedded CodedInputStream to BlockRef"
  [is]
  (serdes.core/cis->embedded cis->BlockRef is))

(defn new-BlockRef
  "Creates a new instance from a map, similar to map->BlockRef except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockRef-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockRef-spec init))))]}
  (-> (merge BlockRef-defaults init)
      (map->BlockRef-record)))

(defn pb->BlockRef
  "Protobuf to BlockRef"
  [input]
  (cis->BlockRef (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockRef-meta {:type "sf.ethereum.type.v2.BlockRef" :decoder pb->BlockRef})

;-----------------------------------------------------------------------------
; TransactionTraceWithBlockRef
;-----------------------------------------------------------------------------
(defrecord TransactionTraceWithBlockRef-record [trace block-ref]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:trace this) os)
    (serdes.core/write-embedded 2 (:block-ref this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.TransactionTraceWithBlockRef"))

(s/def ::TransactionTraceWithBlockRef-spec (s/keys :opt-un []))
(def TransactionTraceWithBlockRef-defaults {})

(defn cis->TransactionTraceWithBlockRef
  "CodedInputStream to TransactionTraceWithBlockRef"
  [is]
  (->> (tag-map TransactionTraceWithBlockRef-defaults
         (fn [tag index]
             (case index
               1 [:trace (ecis->TransactionTrace is)]
               2 [:block-ref (ecis->BlockRef is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TransactionTraceWithBlockRef-record)))

(defn ecis->TransactionTraceWithBlockRef
  "Embedded CodedInputStream to TransactionTraceWithBlockRef"
  [is]
  (serdes.core/cis->embedded cis->TransactionTraceWithBlockRef is))

(defn new-TransactionTraceWithBlockRef
  "Creates a new instance from a map, similar to map->TransactionTraceWithBlockRef except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TransactionTraceWithBlockRef-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TransactionTraceWithBlockRef-spec init))))]}
  (-> (merge TransactionTraceWithBlockRef-defaults init)
      (cond-> (some? (get init :trace)) (update :trace new-TransactionTrace))
      (cond-> (some? (get init :block-ref)) (update :block-ref new-BlockRef))
      (map->TransactionTraceWithBlockRef-record)))

(defn pb->TransactionTraceWithBlockRef
  "Protobuf to TransactionTraceWithBlockRef"
  [input]
  (cis->TransactionTraceWithBlockRef (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TransactionTraceWithBlockRef-meta {:type "sf.ethereum.type.v2.TransactionTraceWithBlockRef" :decoder pb->TransactionTraceWithBlockRef})

;-----------------------------------------------------------------------------
; GasChange
;-----------------------------------------------------------------------------
(defrecord GasChange-record [old-value new-value reason ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:old-value this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:new-value this) os)
    (write-GasChange-Reason 3  {:optimize true} (:reason this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.GasChange"))

(s/def :sf.ethereum.type.v2.GasChange/old-value int?)
(s/def :sf.ethereum.type.v2.GasChange/new-value int?)
(s/def :sf.ethereum.type.v2.GasChange/reason (s/or :keyword keyword? :int int?))
(s/def :sf.ethereum.type.v2.GasChange/ordinal int?)
(s/def ::GasChange-spec (s/keys :opt-un [:sf.ethereum.type.v2.GasChange/old-value :sf.ethereum.type.v2.GasChange/new-value :sf.ethereum.type.v2.GasChange/reason :sf.ethereum.type.v2.GasChange/ordinal ]))
(def GasChange-defaults {:old-value 0 :new-value 0 :reason GasChange-Reason-default :ordinal 0 })

(defn cis->GasChange
  "CodedInputStream to GasChange"
  [is]
  (->> (tag-map GasChange-defaults
         (fn [tag index]
             (case index
               1 [:old-value (serdes.core/cis->UInt64 is)]
               2 [:new-value (serdes.core/cis->UInt64 is)]
               3 [:reason (cis->GasChange-Reason is)]
               4 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GasChange-record)))

(defn ecis->GasChange
  "Embedded CodedInputStream to GasChange"
  [is]
  (serdes.core/cis->embedded cis->GasChange is))

(defn new-GasChange
  "Creates a new instance from a map, similar to map->GasChange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GasChange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GasChange-spec init))))]}
  (-> (merge GasChange-defaults init)
      (map->GasChange-record)))

(defn pb->GasChange
  "Protobuf to GasChange"
  [input]
  (cis->GasChange (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GasChange-meta {:type "sf.ethereum.type.v2.GasChange" :decoder pb->GasChange})

;-----------------------------------------------------------------------------
; StorageChange
;-----------------------------------------------------------------------------
(defrecord StorageChange-record [address key old-value new-value ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:old-value this) os)
    (serdes.core/write-Bytes 4  {:optimize true} (:new-value this) os)
    (serdes.core/write-UInt64 5  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.StorageChange"))

(s/def :sf.ethereum.type.v2.StorageChange/address bytes?)
(s/def :sf.ethereum.type.v2.StorageChange/key bytes?)
(s/def :sf.ethereum.type.v2.StorageChange/old-value bytes?)
(s/def :sf.ethereum.type.v2.StorageChange/new-value bytes?)
(s/def :sf.ethereum.type.v2.StorageChange/ordinal int?)
(s/def ::StorageChange-spec (s/keys :opt-un [:sf.ethereum.type.v2.StorageChange/address :sf.ethereum.type.v2.StorageChange/key :sf.ethereum.type.v2.StorageChange/old-value :sf.ethereum.type.v2.StorageChange/new-value :sf.ethereum.type.v2.StorageChange/ordinal ]))
(def StorageChange-defaults {:address (byte-array 0) :key (byte-array 0) :old-value (byte-array 0) :new-value (byte-array 0) :ordinal 0 })

(defn cis->StorageChange
  "CodedInputStream to StorageChange"
  [is]
  (->> (tag-map StorageChange-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:key (serdes.core/cis->Bytes is)]
               3 [:old-value (serdes.core/cis->Bytes is)]
               4 [:new-value (serdes.core/cis->Bytes is)]
               5 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StorageChange-record)))

(defn ecis->StorageChange
  "Embedded CodedInputStream to StorageChange"
  [is]
  (serdes.core/cis->embedded cis->StorageChange is))

(defn new-StorageChange
  "Creates a new instance from a map, similar to map->StorageChange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StorageChange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StorageChange-spec init))))]}
  (-> (merge StorageChange-defaults init)
      (map->StorageChange-record)))

(defn pb->StorageChange
  "Protobuf to StorageChange"
  [input]
  (cis->StorageChange (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StorageChange-meta {:type "sf.ethereum.type.v2.StorageChange" :decoder pb->StorageChange})

;-----------------------------------------------------------------------------
; Log
;-----------------------------------------------------------------------------
(defrecord Log-record [address topics data index blockIndex ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.complex/write-repeated serdes.core/write-Bytes 2 (:topics this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:data this) os)
    (serdes.core/write-UInt32 4  {:optimize true} (:index this) os)
    (serdes.core/write-UInt32 6  {:optimize true} (:blockIndex this) os)
    (serdes.core/write-UInt64 7  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.Log"))

(s/def :sf.ethereum.type.v2.Log/address bytes?)
(s/def :sf.ethereum.type.v2.Log/topics (s/every bytes?))
(s/def :sf.ethereum.type.v2.Log/data bytes?)
(s/def :sf.ethereum.type.v2.Log/index int?)
(s/def :sf.ethereum.type.v2.Log/blockIndex int?)
(s/def :sf.ethereum.type.v2.Log/ordinal int?)
(s/def ::Log-spec (s/keys :opt-un [:sf.ethereum.type.v2.Log/address :sf.ethereum.type.v2.Log/topics :sf.ethereum.type.v2.Log/data :sf.ethereum.type.v2.Log/index :sf.ethereum.type.v2.Log/blockIndex :sf.ethereum.type.v2.Log/ordinal ]))
(def Log-defaults {:address (byte-array 0) :topics [] :data (byte-array 0) :index 0 :blockIndex 0 :ordinal 0 })

(defn cis->Log
  "CodedInputStream to Log"
  [is]
  (->> (tag-map Log-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:topics (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]
               3 [:data (serdes.core/cis->Bytes is)]
               4 [:index (serdes.core/cis->UInt32 is)]
               6 [:blockIndex (serdes.core/cis->UInt32 is)]
               7 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Log-record)))

(defn ecis->Log
  "Embedded CodedInputStream to Log"
  [is]
  (serdes.core/cis->embedded cis->Log is))

(defn new-Log
  "Creates a new instance from a map, similar to map->Log except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Log-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Log-spec init))))]}
  (-> (merge Log-defaults init)
      (map->Log-record)))

(defn pb->Log
  "Protobuf to Log"
  [input]
  (cis->Log (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Log-meta {:type "sf.ethereum.type.v2.Log" :decoder pb->Log})

;-----------------------------------------------------------------------------
; AccountCreation
;-----------------------------------------------------------------------------
(defrecord AccountCreation-record [account ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:account this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.AccountCreation"))

(s/def :sf.ethereum.type.v2.AccountCreation/account bytes?)
(s/def :sf.ethereum.type.v2.AccountCreation/ordinal int?)
(s/def ::AccountCreation-spec (s/keys :opt-un [:sf.ethereum.type.v2.AccountCreation/account :sf.ethereum.type.v2.AccountCreation/ordinal ]))
(def AccountCreation-defaults {:account (byte-array 0) :ordinal 0 })

(defn cis->AccountCreation
  "CodedInputStream to AccountCreation"
  [is]
  (->> (tag-map AccountCreation-defaults
         (fn [tag index]
             (case index
               1 [:account (serdes.core/cis->Bytes is)]
               2 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->AccountCreation-record)))

(defn ecis->AccountCreation
  "Embedded CodedInputStream to AccountCreation"
  [is]
  (serdes.core/cis->embedded cis->AccountCreation is))

(defn new-AccountCreation
  "Creates a new instance from a map, similar to map->AccountCreation except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AccountCreation-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AccountCreation-spec init))))]}
  (-> (merge AccountCreation-defaults init)
      (map->AccountCreation-record)))

(defn pb->AccountCreation
  "Protobuf to AccountCreation"
  [input]
  (cis->AccountCreation (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record AccountCreation-meta {:type "sf.ethereum.type.v2.AccountCreation" :decoder pb->AccountCreation})

;-----------------------------------------------------------------------------
; CodeChange
;-----------------------------------------------------------------------------
(defrecord CodeChange-record [address old-hash old-code new-hash new-code ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:old-hash this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:old-code this) os)
    (serdes.core/write-Bytes 4  {:optimize true} (:new-hash this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:new-code this) os)
    (serdes.core/write-UInt64 6  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.CodeChange"))

(s/def :sf.ethereum.type.v2.CodeChange/address bytes?)
(s/def :sf.ethereum.type.v2.CodeChange/old-hash bytes?)
(s/def :sf.ethereum.type.v2.CodeChange/old-code bytes?)
(s/def :sf.ethereum.type.v2.CodeChange/new-hash bytes?)
(s/def :sf.ethereum.type.v2.CodeChange/new-code bytes?)
(s/def :sf.ethereum.type.v2.CodeChange/ordinal int?)
(s/def ::CodeChange-spec (s/keys :opt-un [:sf.ethereum.type.v2.CodeChange/address :sf.ethereum.type.v2.CodeChange/old-hash :sf.ethereum.type.v2.CodeChange/old-code :sf.ethereum.type.v2.CodeChange/new-hash :sf.ethereum.type.v2.CodeChange/new-code :sf.ethereum.type.v2.CodeChange/ordinal ]))
(def CodeChange-defaults {:address (byte-array 0) :old-hash (byte-array 0) :old-code (byte-array 0) :new-hash (byte-array 0) :new-code (byte-array 0) :ordinal 0 })

(defn cis->CodeChange
  "CodedInputStream to CodeChange"
  [is]
  (->> (tag-map CodeChange-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:old-hash (serdes.core/cis->Bytes is)]
               3 [:old-code (serdes.core/cis->Bytes is)]
               4 [:new-hash (serdes.core/cis->Bytes is)]
               5 [:new-code (serdes.core/cis->Bytes is)]
               6 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CodeChange-record)))

(defn ecis->CodeChange
  "Embedded CodedInputStream to CodeChange"
  [is]
  (serdes.core/cis->embedded cis->CodeChange is))

(defn new-CodeChange
  "Creates a new instance from a map, similar to map->CodeChange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CodeChange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CodeChange-spec init))))]}
  (-> (merge CodeChange-defaults init)
      (map->CodeChange-record)))

(defn pb->CodeChange
  "Protobuf to CodeChange"
  [input]
  (cis->CodeChange (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CodeChange-meta {:type "sf.ethereum.type.v2.CodeChange" :decoder pb->CodeChange})

;-----------------------------------------------------------------------------
; TransactionTrace
;-----------------------------------------------------------------------------
(defrecord TransactionTrace-record [s index calls access-list hash v gas-limit receipt value gas-used end-ordinal status return-data begin-ordinal input gas-price type r from max-priority-fee-per-gas max-fee-per-gas nonce public-key to]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 9  {:optimize true} (:s this) os)
    (serdes.core/write-UInt32 20  {:optimize true} (:index this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 32 (:calls this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 14 (:access-list this) os)
    (serdes.core/write-Bytes 21  {:optimize true} (:hash this) os)
    (serdes.core/write-Bytes 7  {:optimize true} (:v this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:gas-limit this) os)
    (serdes.core/write-embedded 31 (:receipt this) os)
    (serdes.core/write-embedded 5 (:value this) os)
    (serdes.core/write-UInt64 10  {:optimize true} (:gas-used this) os)
    (serdes.core/write-UInt64 26  {:optimize true} (:end-ordinal this) os)
    (write-TransactionTraceStatus 30  {:optimize true} (:status this) os)
    (serdes.core/write-Bytes 23  {:optimize true} (:return-data this) os)
    (serdes.core/write-UInt64 25  {:optimize true} (:begin-ordinal this) os)
    (serdes.core/write-Bytes 6  {:optimize true} (:input this) os)
    (serdes.core/write-embedded 3 (:gas-price this) os)
    (write-TransactionTrace-Type 12  {:optimize true} (:type this) os)
    (serdes.core/write-Bytes 8  {:optimize true} (:r this) os)
    (serdes.core/write-Bytes 22  {:optimize true} (:from this) os)
    (serdes.core/write-embedded 13 (:max-priority-fee-per-gas this) os)
    (serdes.core/write-embedded 11 (:max-fee-per-gas this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:nonce this) os)
    (serdes.core/write-Bytes 24  {:optimize true} (:public-key this) os)
    (serdes.core/write-Bytes 1  {:optimize true} (:to this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.TransactionTrace"))

(s/def :sf.ethereum.type.v2.TransactionTrace/s bytes?)
(s/def :sf.ethereum.type.v2.TransactionTrace/index int?)


(s/def :sf.ethereum.type.v2.TransactionTrace/hash bytes?)
(s/def :sf.ethereum.type.v2.TransactionTrace/v bytes?)
(s/def :sf.ethereum.type.v2.TransactionTrace/gas-limit int?)


(s/def :sf.ethereum.type.v2.TransactionTrace/gas-used int?)
(s/def :sf.ethereum.type.v2.TransactionTrace/end-ordinal int?)
(s/def :sf.ethereum.type.v2.TransactionTrace/status (s/or :keyword keyword? :int int?))
(s/def :sf.ethereum.type.v2.TransactionTrace/return-data bytes?)
(s/def :sf.ethereum.type.v2.TransactionTrace/begin-ordinal int?)
(s/def :sf.ethereum.type.v2.TransactionTrace/input bytes?)

(s/def :sf.ethereum.type.v2.TransactionTrace/type (s/or :keyword keyword? :int int?))
(s/def :sf.ethereum.type.v2.TransactionTrace/r bytes?)
(s/def :sf.ethereum.type.v2.TransactionTrace/from bytes?)


(s/def :sf.ethereum.type.v2.TransactionTrace/nonce int?)
(s/def :sf.ethereum.type.v2.TransactionTrace/public-key bytes?)
(s/def :sf.ethereum.type.v2.TransactionTrace/to bytes?)
(s/def ::TransactionTrace-spec (s/keys :opt-un [:sf.ethereum.type.v2.TransactionTrace/s :sf.ethereum.type.v2.TransactionTrace/index :sf.ethereum.type.v2.TransactionTrace/hash :sf.ethereum.type.v2.TransactionTrace/v :sf.ethereum.type.v2.TransactionTrace/gas-limit :sf.ethereum.type.v2.TransactionTrace/gas-used :sf.ethereum.type.v2.TransactionTrace/end-ordinal :sf.ethereum.type.v2.TransactionTrace/status :sf.ethereum.type.v2.TransactionTrace/return-data :sf.ethereum.type.v2.TransactionTrace/begin-ordinal :sf.ethereum.type.v2.TransactionTrace/input :sf.ethereum.type.v2.TransactionTrace/type :sf.ethereum.type.v2.TransactionTrace/r :sf.ethereum.type.v2.TransactionTrace/from :sf.ethereum.type.v2.TransactionTrace/nonce :sf.ethereum.type.v2.TransactionTrace/public-key :sf.ethereum.type.v2.TransactionTrace/to ]))
(def TransactionTrace-defaults {:s (byte-array 0) :index 0 :calls [] :access-list [] :hash (byte-array 0) :v (byte-array 0) :gas-limit 0 :gas-used 0 :end-ordinal 0 :status TransactionTraceStatus-default :return-data (byte-array 0) :begin-ordinal 0 :input (byte-array 0) :type TransactionTrace-Type-default :r (byte-array 0) :from (byte-array 0) :nonce 0 :public-key (byte-array 0) :to (byte-array 0) })

(defn cis->TransactionTrace
  "CodedInputStream to TransactionTrace"
  [is]
  (->> (tag-map TransactionTrace-defaults
         (fn [tag index]
             (case index
               9 [:s (serdes.core/cis->Bytes is)]
               20 [:index (serdes.core/cis->UInt32 is)]
               32 [:calls (serdes.complex/cis->repeated ecis->Call is)]
               14 [:access-list (serdes.complex/cis->repeated ecis->AccessTuple is)]
               21 [:hash (serdes.core/cis->Bytes is)]
               7 [:v (serdes.core/cis->Bytes is)]
               4 [:gas-limit (serdes.core/cis->UInt64 is)]
               31 [:receipt (ecis->TransactionReceipt is)]
               5 [:value (ecis->BigInt is)]
               10 [:gas-used (serdes.core/cis->UInt64 is)]
               26 [:end-ordinal (serdes.core/cis->UInt64 is)]
               30 [:status (cis->TransactionTraceStatus is)]
               23 [:return-data (serdes.core/cis->Bytes is)]
               25 [:begin-ordinal (serdes.core/cis->UInt64 is)]
               6 [:input (serdes.core/cis->Bytes is)]
               3 [:gas-price (ecis->BigInt is)]
               12 [:type (cis->TransactionTrace-Type is)]
               8 [:r (serdes.core/cis->Bytes is)]
               22 [:from (serdes.core/cis->Bytes is)]
               13 [:max-priority-fee-per-gas (ecis->BigInt is)]
               11 [:max-fee-per-gas (ecis->BigInt is)]
               2 [:nonce (serdes.core/cis->UInt64 is)]
               24 [:public-key (serdes.core/cis->Bytes is)]
               1 [:to (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TransactionTrace-record)))

(defn ecis->TransactionTrace
  "Embedded CodedInputStream to TransactionTrace"
  [is]
  (serdes.core/cis->embedded cis->TransactionTrace is))

(defn new-TransactionTrace
  "Creates a new instance from a map, similar to map->TransactionTrace except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TransactionTrace-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TransactionTrace-spec init))))]}
  (-> (merge TransactionTrace-defaults init)
      (cond-> (some? (get init :gas-price)) (update :gas-price new-BigInt))
      (cond-> (some? (get init :value)) (update :value new-BigInt))
      (cond-> (some? (get init :access-list)) (update :access-list #(map new-AccessTuple %)))
      (cond-> (some? (get init :max-fee-per-gas)) (update :max-fee-per-gas new-BigInt))
      (cond-> (some? (get init :max-priority-fee-per-gas)) (update :max-priority-fee-per-gas new-BigInt))
      (cond-> (some? (get init :receipt)) (update :receipt new-TransactionReceipt))
      (cond-> (some? (get init :calls)) (update :calls #(map new-Call %)))
      (map->TransactionTrace-record)))

(defn pb->TransactionTrace
  "Protobuf to TransactionTrace"
  [input]
  (cis->TransactionTrace (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TransactionTrace-meta {:type "sf.ethereum.type.v2.TransactionTrace" :decoder pb->TransactionTrace})

;-----------------------------------------------------------------------------
; TransactionReceipt
;-----------------------------------------------------------------------------
(defrecord TransactionReceipt-record [state-root cumulative-gas-used logs-bloom logs]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:state-root this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:cumulative-gas-used this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:logs-bloom this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:logs this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.TransactionReceipt"))

(s/def :sf.ethereum.type.v2.TransactionReceipt/state-root bytes?)
(s/def :sf.ethereum.type.v2.TransactionReceipt/cumulative-gas-used int?)
(s/def :sf.ethereum.type.v2.TransactionReceipt/logs-bloom bytes?)

(s/def ::TransactionReceipt-spec (s/keys :opt-un [:sf.ethereum.type.v2.TransactionReceipt/state-root :sf.ethereum.type.v2.TransactionReceipt/cumulative-gas-used :sf.ethereum.type.v2.TransactionReceipt/logs-bloom ]))
(def TransactionReceipt-defaults {:state-root (byte-array 0) :cumulative-gas-used 0 :logs-bloom (byte-array 0) :logs [] })

(defn cis->TransactionReceipt
  "CodedInputStream to TransactionReceipt"
  [is]
  (->> (tag-map TransactionReceipt-defaults
         (fn [tag index]
             (case index
               1 [:state-root (serdes.core/cis->Bytes is)]
               2 [:cumulative-gas-used (serdes.core/cis->UInt64 is)]
               3 [:logs-bloom (serdes.core/cis->Bytes is)]
               4 [:logs (serdes.complex/cis->repeated ecis->Log is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TransactionReceipt-record)))

(defn ecis->TransactionReceipt
  "Embedded CodedInputStream to TransactionReceipt"
  [is]
  (serdes.core/cis->embedded cis->TransactionReceipt is))

(defn new-TransactionReceipt
  "Creates a new instance from a map, similar to map->TransactionReceipt except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TransactionReceipt-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TransactionReceipt-spec init))))]}
  (-> (merge TransactionReceipt-defaults init)
      (cond-> (some? (get init :logs)) (update :logs #(map new-Log %)))
      (map->TransactionReceipt-record)))

(defn pb->TransactionReceipt
  "Protobuf to TransactionReceipt"
  [input]
  (cis->TransactionReceipt (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TransactionReceipt-meta {:type "sf.ethereum.type.v2.TransactionReceipt" :decoder pb->TransactionReceipt})

;-----------------------------------------------------------------------------
; TransactionRefs
;-----------------------------------------------------------------------------
(defrecord TransactionRefs-record [hashes]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-Bytes 1 (:hashes this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.TransactionRefs"))

(s/def :sf.ethereum.type.v2.TransactionRefs/hashes (s/every bytes?))
(s/def ::TransactionRefs-spec (s/keys :opt-un [:sf.ethereum.type.v2.TransactionRefs/hashes ]))
(def TransactionRefs-defaults {:hashes [] })

(defn cis->TransactionRefs
  "CodedInputStream to TransactionRefs"
  [is]
  (->> (tag-map TransactionRefs-defaults
         (fn [tag index]
             (case index
               1 [:hashes (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TransactionRefs-record)))

(defn ecis->TransactionRefs
  "Embedded CodedInputStream to TransactionRefs"
  [is]
  (serdes.core/cis->embedded cis->TransactionRefs is))

(defn new-TransactionRefs
  "Creates a new instance from a map, similar to map->TransactionRefs except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TransactionRefs-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TransactionRefs-spec init))))]}
  (-> (merge TransactionRefs-defaults init)
      (map->TransactionRefs-record)))

(defn pb->TransactionRefs
  "Protobuf to TransactionRefs"
  [input]
  (cis->TransactionRefs (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TransactionRefs-meta {:type "sf.ethereum.type.v2.TransactionRefs" :decoder pb->TransactionRefs})

;-----------------------------------------------------------------------------
; Uint64Array
;-----------------------------------------------------------------------------
(defrecord Uint64Array-record [val]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-UInt64 1 (:val this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.Uint64Array"))

(s/def :sf.ethereum.type.v2.Uint64Array/val (s/every int?))
(s/def ::Uint64Array-spec (s/keys :opt-un [:sf.ethereum.type.v2.Uint64Array/val ]))
(def Uint64Array-defaults {:val [] })

(defn cis->Uint64Array
  "CodedInputStream to Uint64Array"
  [is]
  (->> (tag-map Uint64Array-defaults
         (fn [tag index]
             (case index
               1 [:val (serdes.complex/cis->packablerepeated tag serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Uint64Array-record)))

(defn ecis->Uint64Array
  "Embedded CodedInputStream to Uint64Array"
  [is]
  (serdes.core/cis->embedded cis->Uint64Array is))

(defn new-Uint64Array
  "Creates a new instance from a map, similar to map->Uint64Array except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Uint64Array-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Uint64Array-spec init))))]}
  (-> (merge Uint64Array-defaults init)
      (map->Uint64Array-record)))

(defn pb->Uint64Array
  "Protobuf to Uint64Array"
  [input]
  (cis->Uint64Array (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Uint64Array-meta {:type "sf.ethereum.type.v2.Uint64Array" :decoder pb->Uint64Array})

;-----------------------------------------------------------------------------
; Block
;-----------------------------------------------------------------------------
(defrecord Block-record [uncles balance-changes code-changes hash transaction-traces number size ver header]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 6 (:uncles this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 11 (:balance-changes this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 20 (:code-changes this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:hash this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 10 (:transaction-traces this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:number this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:size this) os)
    (serdes.core/write-Int32 1  {:optimize true} (:ver this) os)
    (serdes.core/write-embedded 5 (:header this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.Block"))

(s/def :sf.ethereum.type.v2.Block/hash bytes?)

(s/def :sf.ethereum.type.v2.Block/number int?)
(s/def :sf.ethereum.type.v2.Block/size int?)
(s/def :sf.ethereum.type.v2.Block/ver int?)

(s/def ::Block-spec (s/keys :opt-un [:sf.ethereum.type.v2.Block/hash :sf.ethereum.type.v2.Block/number :sf.ethereum.type.v2.Block/size :sf.ethereum.type.v2.Block/ver ]))
(def Block-defaults {:uncles [] :balance-changes [] :code-changes [] :hash (byte-array 0) :transaction-traces [] :number 0 :size 0 :ver 0 })

(defn cis->Block
  "CodedInputStream to Block"
  [is]
  (->> (tag-map Block-defaults
         (fn [tag index]
             (case index
               6 [:uncles (serdes.complex/cis->repeated ecis->BlockHeader is)]
               11 [:balance-changes (serdes.complex/cis->repeated ecis->BalanceChange is)]
               20 [:code-changes (serdes.complex/cis->repeated ecis->CodeChange is)]
               2 [:hash (serdes.core/cis->Bytes is)]
               10 [:transaction-traces (serdes.complex/cis->repeated ecis->TransactionTrace is)]
               3 [:number (serdes.core/cis->UInt64 is)]
               4 [:size (serdes.core/cis->UInt64 is)]
               1 [:ver (serdes.core/cis->Int32 is)]
               5 [:header (ecis->BlockHeader is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Block-record)))

(defn ecis->Block
  "Embedded CodedInputStream to Block"
  [is]
  (serdes.core/cis->embedded cis->Block is))

(defn new-Block
  "Creates a new instance from a map, similar to map->Block except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Block-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Block-spec init))))]}
  (-> (merge Block-defaults init)
      (cond-> (some? (get init :header)) (update :header new-BlockHeader))
      (cond-> (some? (get init :uncles)) (update :uncles #(map new-BlockHeader %)))
      (cond-> (some? (get init :transaction-traces)) (update :transaction-traces #(map new-TransactionTrace %)))
      (cond-> (some? (get init :balance-changes)) (update :balance-changes #(map new-BalanceChange %)))
      (cond-> (some? (get init :code-changes)) (update :code-changes #(map new-CodeChange %)))
      (map->Block-record)))

(defn pb->Block
  "Protobuf to Block"
  [input]
  (cis->Block (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Block-meta {:type "sf.ethereum.type.v2.Block" :decoder pb->Block})

;-----------------------------------------------------------------------------
; HeaderOnlyBlock
;-----------------------------------------------------------------------------
(defrecord HeaderOnlyBlock-record [header]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 5 (:header this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.HeaderOnlyBlock"))

(s/def ::HeaderOnlyBlock-spec (s/keys :opt-un []))
(def HeaderOnlyBlock-defaults {})

(defn cis->HeaderOnlyBlock
  "CodedInputStream to HeaderOnlyBlock"
  [is]
  (->> (tag-map HeaderOnlyBlock-defaults
         (fn [tag index]
             (case index
               5 [:header (ecis->BlockHeader is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->HeaderOnlyBlock-record)))

(defn ecis->HeaderOnlyBlock
  "Embedded CodedInputStream to HeaderOnlyBlock"
  [is]
  (serdes.core/cis->embedded cis->HeaderOnlyBlock is))

(defn new-HeaderOnlyBlock
  "Creates a new instance from a map, similar to map->HeaderOnlyBlock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HeaderOnlyBlock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HeaderOnlyBlock-spec init))))]}
  (-> (merge HeaderOnlyBlock-defaults init)
      (cond-> (some? (get init :header)) (update :header new-BlockHeader))
      (map->HeaderOnlyBlock-record)))

(defn pb->HeaderOnlyBlock
  "Protobuf to HeaderOnlyBlock"
  [input]
  (cis->HeaderOnlyBlock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record HeaderOnlyBlock-meta {:type "sf.ethereum.type.v2.HeaderOnlyBlock" :decoder pb->HeaderOnlyBlock})

;-----------------------------------------------------------------------------
; BlockHeader
;-----------------------------------------------------------------------------
(defrecord BlockHeader-record [state-root receipt-root extra-data coinbase hash logs-bloom gas-limit timestamp uncle-hash withdrawals-root mix-hash gas-used number difficulty tx-dependency base-fee-per-gas parent-hash nonce total-difficulty transactions-root]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 4  {:optimize true} (:state-root this) os)
    (serdes.core/write-Bytes 6  {:optimize true} (:receipt-root this) os)
    (serdes.core/write-Bytes 13  {:optimize true} (:extra-data this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:coinbase this) os)
    (serdes.core/write-Bytes 16  {:optimize true} (:hash this) os)
    (serdes.core/write-Bytes 7  {:optimize true} (:logs-bloom this) os)
    (serdes.core/write-UInt64 10  {:optimize true} (:gas-limit this) os)
    (serdes.core/write-embedded 12 (:timestamp this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:uncle-hash this) os)
    (serdes.core/write-Bytes 19  {:optimize true} (:withdrawals-root this) os)
    (serdes.core/write-Bytes 14  {:optimize true} (:mix-hash this) os)
    (serdes.core/write-UInt64 11  {:optimize true} (:gas-used this) os)
    (serdes.core/write-UInt64 9  {:optimize true} (:number this) os)
    (serdes.core/write-embedded 8 (:difficulty this) os)
    (serdes.core/write-embedded 20 (:tx-dependency this) os)
    (serdes.core/write-embedded 18 (:base-fee-per-gas this) os)
    (serdes.core/write-Bytes 1  {:optimize true} (:parent-hash this) os)
    (serdes.core/write-UInt64 15  {:optimize true} (:nonce this) os)
    (serdes.core/write-embedded 17 (:total-difficulty this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:transactions-root this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.BlockHeader"))

(s/def :sf.ethereum.type.v2.BlockHeader/state-root bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/receipt-root bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/extra-data bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/coinbase bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/hash bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/logs-bloom bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/gas-limit int?)

(s/def :sf.ethereum.type.v2.BlockHeader/uncle-hash bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/withdrawals-root bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/mix-hash bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/gas-used int?)
(s/def :sf.ethereum.type.v2.BlockHeader/number int?)



(s/def :sf.ethereum.type.v2.BlockHeader/parent-hash bytes?)
(s/def :sf.ethereum.type.v2.BlockHeader/nonce int?)

(s/def :sf.ethereum.type.v2.BlockHeader/transactions-root bytes?)
(s/def ::BlockHeader-spec (s/keys :opt-un [:sf.ethereum.type.v2.BlockHeader/state-root :sf.ethereum.type.v2.BlockHeader/receipt-root :sf.ethereum.type.v2.BlockHeader/extra-data :sf.ethereum.type.v2.BlockHeader/coinbase :sf.ethereum.type.v2.BlockHeader/hash :sf.ethereum.type.v2.BlockHeader/logs-bloom :sf.ethereum.type.v2.BlockHeader/gas-limit :sf.ethereum.type.v2.BlockHeader/uncle-hash :sf.ethereum.type.v2.BlockHeader/withdrawals-root :sf.ethereum.type.v2.BlockHeader/mix-hash :sf.ethereum.type.v2.BlockHeader/gas-used :sf.ethereum.type.v2.BlockHeader/number :sf.ethereum.type.v2.BlockHeader/parent-hash :sf.ethereum.type.v2.BlockHeader/nonce :sf.ethereum.type.v2.BlockHeader/transactions-root ]))
(def BlockHeader-defaults {:state-root (byte-array 0) :receipt-root (byte-array 0) :extra-data (byte-array 0) :coinbase (byte-array 0) :hash (byte-array 0) :logs-bloom (byte-array 0) :gas-limit 0 :uncle-hash (byte-array 0) :withdrawals-root (byte-array 0) :mix-hash (byte-array 0) :gas-used 0 :number 0 :parent-hash (byte-array 0) :nonce 0 :transactions-root (byte-array 0) })

(defn cis->BlockHeader
  "CodedInputStream to BlockHeader"
  [is]
  (->> (tag-map BlockHeader-defaults
         (fn [tag index]
             (case index
               4 [:state-root (serdes.core/cis->Bytes is)]
               6 [:receipt-root (serdes.core/cis->Bytes is)]
               13 [:extra-data (serdes.core/cis->Bytes is)]
               3 [:coinbase (serdes.core/cis->Bytes is)]
               16 [:hash (serdes.core/cis->Bytes is)]
               7 [:logs-bloom (serdes.core/cis->Bytes is)]
               10 [:gas-limit (serdes.core/cis->UInt64 is)]
               12 [:timestamp (com.google.protobuf/ecis->Timestamp is)]
               2 [:uncle-hash (serdes.core/cis->Bytes is)]
               19 [:withdrawals-root (serdes.core/cis->Bytes is)]
               14 [:mix-hash (serdes.core/cis->Bytes is)]
               11 [:gas-used (serdes.core/cis->UInt64 is)]
               9 [:number (serdes.core/cis->UInt64 is)]
               8 [:difficulty (ecis->BigInt is)]
               20 [:tx-dependency (ecis->Uint64NestedArray is)]
               18 [:base-fee-per-gas (ecis->BigInt is)]
               1 [:parent-hash (serdes.core/cis->Bytes is)]
               15 [:nonce (serdes.core/cis->UInt64 is)]
               17 [:total-difficulty (ecis->BigInt is)]
               5 [:transactions-root (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockHeader-record)))

(defn ecis->BlockHeader
  "Embedded CodedInputStream to BlockHeader"
  [is]
  (serdes.core/cis->embedded cis->BlockHeader is))

(defn new-BlockHeader
  "Creates a new instance from a map, similar to map->BlockHeader except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockHeader-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockHeader-spec init))))]}
  (-> (merge BlockHeader-defaults init)
      (cond-> (some? (get init :difficulty)) (update :difficulty new-BigInt))
      (cond-> (some? (get init :total-difficulty)) (update :total-difficulty new-BigInt))
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (cond-> (some? (get init :base-fee-per-gas)) (update :base-fee-per-gas new-BigInt))
      (cond-> (some? (get init :tx-dependency)) (update :tx-dependency new-Uint64NestedArray))
      (map->BlockHeader-record)))

(defn pb->BlockHeader
  "Protobuf to BlockHeader"
  [input]
  (cis->BlockHeader (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockHeader-meta {:type "sf.ethereum.type.v2.BlockHeader" :decoder pb->BlockHeader})

;-----------------------------------------------------------------------------
; BigInt
;-----------------------------------------------------------------------------
(defrecord BigInt-record [bytes]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:bytes this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.BigInt"))

(s/def :sf.ethereum.type.v2.BigInt/bytes bytes?)
(s/def ::BigInt-spec (s/keys :opt-un [:sf.ethereum.type.v2.BigInt/bytes ]))
(def BigInt-defaults {:bytes (byte-array 0) })

(defn cis->BigInt
  "CodedInputStream to BigInt"
  [is]
  (->> (tag-map BigInt-defaults
         (fn [tag index]
             (case index
               1 [:bytes (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BigInt-record)))

(defn ecis->BigInt
  "Embedded CodedInputStream to BigInt"
  [is]
  (serdes.core/cis->embedded cis->BigInt is))

(defn new-BigInt
  "Creates a new instance from a map, similar to map->BigInt except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BigInt-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BigInt-spec init))))]}
  (-> (merge BigInt-defaults init)
      (map->BigInt-record)))

(defn pb->BigInt
  "Protobuf to BigInt"
  [input]
  (cis->BigInt (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BigInt-meta {:type "sf.ethereum.type.v2.BigInt" :decoder pb->BigInt})

;-----------------------------------------------------------------------------
; BalanceChange
;-----------------------------------------------------------------------------
(defrecord BalanceChange-record [address old-value new-value reason ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.core/write-embedded 2 (:old-value this) os)
    (serdes.core/write-embedded 3 (:new-value this) os)
    (write-BalanceChange-Reason 4  {:optimize true} (:reason this) os)
    (serdes.core/write-UInt64 5  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.BalanceChange"))

(s/def :sf.ethereum.type.v2.BalanceChange/address bytes?)


(s/def :sf.ethereum.type.v2.BalanceChange/reason (s/or :keyword keyword? :int int?))
(s/def :sf.ethereum.type.v2.BalanceChange/ordinal int?)
(s/def ::BalanceChange-spec (s/keys :opt-un [:sf.ethereum.type.v2.BalanceChange/address :sf.ethereum.type.v2.BalanceChange/reason :sf.ethereum.type.v2.BalanceChange/ordinal ]))
(def BalanceChange-defaults {:address (byte-array 0) :reason BalanceChange-Reason-default :ordinal 0 })

(defn cis->BalanceChange
  "CodedInputStream to BalanceChange"
  [is]
  (->> (tag-map BalanceChange-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:old-value (ecis->BigInt is)]
               3 [:new-value (ecis->BigInt is)]
               4 [:reason (cis->BalanceChange-Reason is)]
               5 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BalanceChange-record)))

(defn ecis->BalanceChange
  "Embedded CodedInputStream to BalanceChange"
  [is]
  (serdes.core/cis->embedded cis->BalanceChange is))

(defn new-BalanceChange
  "Creates a new instance from a map, similar to map->BalanceChange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BalanceChange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BalanceChange-spec init))))]}
  (-> (merge BalanceChange-defaults init)
      (cond-> (some? (get init :old-value)) (update :old-value new-BigInt))
      (cond-> (some? (get init :new-value)) (update :new-value new-BigInt))
      (map->BalanceChange-record)))

(defn pb->BalanceChange
  "Protobuf to BalanceChange"
  [input]
  (cis->BalanceChange (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BalanceChange-meta {:type "sf.ethereum.type.v2.BalanceChange" :decoder pb->BalanceChange})

;-----------------------------------------------------------------------------
; AccessTuple
;-----------------------------------------------------------------------------
(defrecord AccessTuple-record [address storage-keys]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.complex/write-repeated serdes.core/write-Bytes 2 (:storage-keys this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.AccessTuple"))

(s/def :sf.ethereum.type.v2.AccessTuple/address bytes?)
(s/def :sf.ethereum.type.v2.AccessTuple/storage-keys (s/every bytes?))
(s/def ::AccessTuple-spec (s/keys :opt-un [:sf.ethereum.type.v2.AccessTuple/address :sf.ethereum.type.v2.AccessTuple/storage-keys ]))
(def AccessTuple-defaults {:address (byte-array 0) :storage-keys [] })

(defn cis->AccessTuple
  "CodedInputStream to AccessTuple"
  [is]
  (->> (tag-map AccessTuple-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:storage-keys (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->AccessTuple-record)))

(defn ecis->AccessTuple
  "Embedded CodedInputStream to AccessTuple"
  [is]
  (serdes.core/cis->embedded cis->AccessTuple is))

(defn new-AccessTuple
  "Creates a new instance from a map, similar to map->AccessTuple except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AccessTuple-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AccessTuple-spec init))))]}
  (-> (merge AccessTuple-defaults init)
      (map->AccessTuple-record)))

(defn pb->AccessTuple
  "Protobuf to AccessTuple"
  [input]
  (cis->AccessTuple (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record AccessTuple-meta {:type "sf.ethereum.type.v2.AccessTuple" :decoder pb->AccessTuple})

;-----------------------------------------------------------------------------
; BlockWithRefs
;-----------------------------------------------------------------------------
(defrecord BlockWithRefs-record [id block transaction-trace-refs irreversible]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:id this) os)
    (serdes.core/write-embedded 2 (:block this) os)
    (serdes.core/write-embedded 3 (:transaction-trace-refs this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:irreversible this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.BlockWithRefs"))

(s/def :sf.ethereum.type.v2.BlockWithRefs/id string?)


(s/def :sf.ethereum.type.v2.BlockWithRefs/irreversible boolean?)
(s/def ::BlockWithRefs-spec (s/keys :opt-un [:sf.ethereum.type.v2.BlockWithRefs/id :sf.ethereum.type.v2.BlockWithRefs/irreversible ]))
(def BlockWithRefs-defaults {:id "" :irreversible false })

(defn cis->BlockWithRefs
  "CodedInputStream to BlockWithRefs"
  [is]
  (->> (tag-map BlockWithRefs-defaults
         (fn [tag index]
             (case index
               1 [:id (serdes.core/cis->String is)]
               2 [:block (ecis->Block is)]
               3 [:transaction-trace-refs (ecis->TransactionRefs is)]
               4 [:irreversible (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockWithRefs-record)))

(defn ecis->BlockWithRefs
  "Embedded CodedInputStream to BlockWithRefs"
  [is]
  (serdes.core/cis->embedded cis->BlockWithRefs is))

(defn new-BlockWithRefs
  "Creates a new instance from a map, similar to map->BlockWithRefs except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockWithRefs-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockWithRefs-spec init))))]}
  (-> (merge BlockWithRefs-defaults init)
      (cond-> (some? (get init :block)) (update :block new-Block))
      (cond-> (some? (get init :transaction-trace-refs)) (update :transaction-trace-refs new-TransactionRefs))
      (map->BlockWithRefs-record)))

(defn pb->BlockWithRefs
  "Protobuf to BlockWithRefs"
  [input]
  (cis->BlockWithRefs (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockWithRefs-meta {:type "sf.ethereum.type.v2.BlockWithRefs" :decoder pb->BlockWithRefs})

;-----------------------------------------------------------------------------
; Call
;-----------------------------------------------------------------------------
(defrecord Call-record [suicide balance-changes gas-changes index keccak-preimages code-changes parent-index gas-limit nonce-changes value caller address end-ordinal call-type return-data logs begin-ordinal executed-code input depth status-failed failure-reason status-reverted storage-changes state-reverted gas-consumed account-creations]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 16  {:optimize true} (:suicide this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 22 (:balance-changes this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 28 (:gas-changes this) os)
    (serdes.core/write-UInt32 1  {:optimize true} (:index this) os)
    (serdes.complex/write-map new-Call-KeccakPreimagesEntry 20 (:keccak-preimages this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 26 (:code-changes this) os)
    (serdes.core/write-UInt32 2  {:optimize true} (:parent-index this) os)
    (serdes.core/write-UInt64 8  {:optimize true} (:gas-limit this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 24 (:nonce-changes this) os)
    (serdes.core/write-embedded 7 (:value this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:caller this) os)
    (serdes.core/write-Bytes 6  {:optimize true} (:address this) os)
    (serdes.core/write-UInt64 32  {:optimize true} (:end-ordinal this) os)
    (write-CallType 4  {:optimize true} (:call-type this) os)
    (serdes.core/write-Bytes 13  {:optimize true} (:return-data this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 25 (:logs this) os)
    (serdes.core/write-UInt64 31  {:optimize true} (:begin-ordinal this) os)
    (serdes.core/write-Bool 15  {:optimize true} (:executed-code this) os)
    (serdes.core/write-Bytes 14  {:optimize true} (:input this) os)
    (serdes.core/write-UInt32 3  {:optimize true} (:depth this) os)
    (serdes.core/write-Bool 10  {:optimize true} (:status-failed this) os)
    (serdes.core/write-String 11  {:optimize true} (:failure-reason this) os)
    (serdes.core/write-Bool 12  {:optimize true} (:status-reverted this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 21 (:storage-changes this) os)
    (serdes.core/write-Bool 30  {:optimize true} (:state-reverted this) os)
    (serdes.core/write-UInt64 9  {:optimize true} (:gas-consumed this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 33 (:account-creations this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.Call"))

(s/def :sf.ethereum.type.v2.Call/suicide boolean?)


(s/def :sf.ethereum.type.v2.Call/index int?)


(s/def :sf.ethereum.type.v2.Call/parent-index int?)
(s/def :sf.ethereum.type.v2.Call/gas-limit int?)


(s/def :sf.ethereum.type.v2.Call/caller bytes?)
(s/def :sf.ethereum.type.v2.Call/address bytes?)
(s/def :sf.ethereum.type.v2.Call/end-ordinal int?)
(s/def :sf.ethereum.type.v2.Call/call-type (s/or :keyword keyword? :int int?))
(s/def :sf.ethereum.type.v2.Call/return-data bytes?)

(s/def :sf.ethereum.type.v2.Call/begin-ordinal int?)
(s/def :sf.ethereum.type.v2.Call/executed-code boolean?)
(s/def :sf.ethereum.type.v2.Call/input bytes?)
(s/def :sf.ethereum.type.v2.Call/depth int?)
(s/def :sf.ethereum.type.v2.Call/status-failed boolean?)
(s/def :sf.ethereum.type.v2.Call/failure-reason string?)
(s/def :sf.ethereum.type.v2.Call/status-reverted boolean?)

(s/def :sf.ethereum.type.v2.Call/state-reverted boolean?)
(s/def :sf.ethereum.type.v2.Call/gas-consumed int?)

(s/def ::Call-spec (s/keys :opt-un [:sf.ethereum.type.v2.Call/suicide :sf.ethereum.type.v2.Call/index :sf.ethereum.type.v2.Call/parent-index :sf.ethereum.type.v2.Call/gas-limit :sf.ethereum.type.v2.Call/caller :sf.ethereum.type.v2.Call/address :sf.ethereum.type.v2.Call/end-ordinal :sf.ethereum.type.v2.Call/call-type :sf.ethereum.type.v2.Call/return-data :sf.ethereum.type.v2.Call/begin-ordinal :sf.ethereum.type.v2.Call/executed-code :sf.ethereum.type.v2.Call/input :sf.ethereum.type.v2.Call/depth :sf.ethereum.type.v2.Call/status-failed :sf.ethereum.type.v2.Call/failure-reason :sf.ethereum.type.v2.Call/status-reverted :sf.ethereum.type.v2.Call/state-reverted :sf.ethereum.type.v2.Call/gas-consumed ]))
(def Call-defaults {:suicide false :balance-changes [] :gas-changes [] :index 0 :keccak-preimages [] :code-changes [] :parent-index 0 :gas-limit 0 :nonce-changes [] :caller (byte-array 0) :address (byte-array 0) :end-ordinal 0 :call-type CallType-default :return-data (byte-array 0) :logs [] :begin-ordinal 0 :executed-code false :input (byte-array 0) :depth 0 :status-failed false :failure-reason "" :status-reverted false :storage-changes [] :state-reverted false :gas-consumed 0 :account-creations [] })

(defn cis->Call
  "CodedInputStream to Call"
  [is]
  (->> (tag-map Call-defaults
         (fn [tag index]
             (case index
               16 [:suicide (serdes.core/cis->Bool is)]
               22 [:balance-changes (serdes.complex/cis->repeated ecis->BalanceChange is)]
               28 [:gas-changes (serdes.complex/cis->repeated ecis->GasChange is)]
               1 [:index (serdes.core/cis->UInt32 is)]
               20 [:keccak-preimages (serdes.complex/cis->map ecis->Call-KeccakPreimagesEntry is)]
               26 [:code-changes (serdes.complex/cis->repeated ecis->CodeChange is)]
               2 [:parent-index (serdes.core/cis->UInt32 is)]
               8 [:gas-limit (serdes.core/cis->UInt64 is)]
               24 [:nonce-changes (serdes.complex/cis->repeated ecis->NonceChange is)]
               7 [:value (ecis->BigInt is)]
               5 [:caller (serdes.core/cis->Bytes is)]
               6 [:address (serdes.core/cis->Bytes is)]
               32 [:end-ordinal (serdes.core/cis->UInt64 is)]
               4 [:call-type (cis->CallType is)]
               13 [:return-data (serdes.core/cis->Bytes is)]
               25 [:logs (serdes.complex/cis->repeated ecis->Log is)]
               31 [:begin-ordinal (serdes.core/cis->UInt64 is)]
               15 [:executed-code (serdes.core/cis->Bool is)]
               14 [:input (serdes.core/cis->Bytes is)]
               3 [:depth (serdes.core/cis->UInt32 is)]
               10 [:status-failed (serdes.core/cis->Bool is)]
               11 [:failure-reason (serdes.core/cis->String is)]
               12 [:status-reverted (serdes.core/cis->Bool is)]
               21 [:storage-changes (serdes.complex/cis->repeated ecis->StorageChange is)]
               30 [:state-reverted (serdes.core/cis->Bool is)]
               9 [:gas-consumed (serdes.core/cis->UInt64 is)]
               33 [:account-creations (serdes.complex/cis->repeated ecis->AccountCreation is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Call-record)))

(defn ecis->Call
  "Embedded CodedInputStream to Call"
  [is]
  (serdes.core/cis->embedded cis->Call is))

(defn new-Call
  "Creates a new instance from a map, similar to map->Call except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Call-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Call-spec init))))]}
  (-> (merge Call-defaults init)
      (cond-> (some? (get init :value)) (update :value new-BigInt))
      (cond-> (some? (get init :storage-changes)) (update :storage-changes #(map new-StorageChange %)))
      (cond-> (some? (get init :balance-changes)) (update :balance-changes #(map new-BalanceChange %)))
      (cond-> (some? (get init :nonce-changes)) (update :nonce-changes #(map new-NonceChange %)))
      (cond-> (some? (get init :logs)) (update :logs #(map new-Log %)))
      (cond-> (some? (get init :code-changes)) (update :code-changes #(map new-CodeChange %)))
      (cond-> (some? (get init :gas-changes)) (update :gas-changes #(map new-GasChange %)))
      (cond-> (some? (get init :account-creations)) (update :account-creations #(map new-AccountCreation %)))
      (map->Call-record)))

(defn pb->Call
  "Protobuf to Call"
  [input]
  (cis->Call (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Call-meta {:type "sf.ethereum.type.v2.Call" :decoder pb->Call})

;-----------------------------------------------------------------------------
; Call-KeccakPreimagesEntry
;-----------------------------------------------------------------------------
(defrecord Call-KeccakPreimagesEntry-record [key value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:key this) os)
    (serdes.core/write-String 2  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.Call-KeccakPreimagesEntry"))

(s/def :sf.ethereum.type.v2.Call-KeccakPreimagesEntry/key string?)
(s/def :sf.ethereum.type.v2.Call-KeccakPreimagesEntry/value string?)
(s/def ::Call-KeccakPreimagesEntry-spec (s/keys :opt-un [:sf.ethereum.type.v2.Call-KeccakPreimagesEntry/key :sf.ethereum.type.v2.Call-KeccakPreimagesEntry/value ]))
(def Call-KeccakPreimagesEntry-defaults {:key "" :value "" })

(defn cis->Call-KeccakPreimagesEntry
  "CodedInputStream to Call-KeccakPreimagesEntry"
  [is]
  (->> (tag-map Call-KeccakPreimagesEntry-defaults
         (fn [tag index]
             (case index
               1 [:key (serdes.core/cis->String is)]
               2 [:value (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Call-KeccakPreimagesEntry-record)))

(defn ecis->Call-KeccakPreimagesEntry
  "Embedded CodedInputStream to Call-KeccakPreimagesEntry"
  [is]
  (serdes.core/cis->embedded cis->Call-KeccakPreimagesEntry is))

(defn new-Call-KeccakPreimagesEntry
  "Creates a new instance from a map, similar to map->Call-KeccakPreimagesEntry except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Call-KeccakPreimagesEntry-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Call-KeccakPreimagesEntry-spec init))))]}
  (-> (merge Call-KeccakPreimagesEntry-defaults init)
      (map->Call-KeccakPreimagesEntry-record)))

(defn pb->Call-KeccakPreimagesEntry
  "Protobuf to Call-KeccakPreimagesEntry"
  [input]
  (cis->Call-KeccakPreimagesEntry (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Call-KeccakPreimagesEntry-meta {:type "sf.ethereum.type.v2.Call-KeccakPreimagesEntry" :decoder pb->Call-KeccakPreimagesEntry})

;-----------------------------------------------------------------------------
; NonceChange
;-----------------------------------------------------------------------------
(defrecord NonceChange-record [address old-value new-value ordinal]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:old-value this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:new-value this) os)
    (serdes.core/write-UInt64 4  {:optimize true} (:ordinal this) os))
  pb/TypeReflection
  (gettype [this]
    "sf.ethereum.type.v2.NonceChange"))

(s/def :sf.ethereum.type.v2.NonceChange/address bytes?)
(s/def :sf.ethereum.type.v2.NonceChange/old-value int?)
(s/def :sf.ethereum.type.v2.NonceChange/new-value int?)
(s/def :sf.ethereum.type.v2.NonceChange/ordinal int?)
(s/def ::NonceChange-spec (s/keys :opt-un [:sf.ethereum.type.v2.NonceChange/address :sf.ethereum.type.v2.NonceChange/old-value :sf.ethereum.type.v2.NonceChange/new-value :sf.ethereum.type.v2.NonceChange/ordinal ]))
(def NonceChange-defaults {:address (byte-array 0) :old-value 0 :new-value 0 :ordinal 0 })

(defn cis->NonceChange
  "CodedInputStream to NonceChange"
  [is]
  (->> (tag-map NonceChange-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:old-value (serdes.core/cis->UInt64 is)]
               3 [:new-value (serdes.core/cis->UInt64 is)]
               4 [:ordinal (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->NonceChange-record)))

(defn ecis->NonceChange
  "Embedded CodedInputStream to NonceChange"
  [is]
  (serdes.core/cis->embedded cis->NonceChange is))

(defn new-NonceChange
  "Creates a new instance from a map, similar to map->NonceChange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::NonceChange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::NonceChange-spec init))))]}
  (-> (merge NonceChange-defaults init)
      (map->NonceChange-record)))

(defn pb->NonceChange
  "Protobuf to NonceChange"
  [input]
  (cis->NonceChange (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record NonceChange-meta {:type "sf.ethereum.type.v2.NonceChange" :decoder pb->NonceChange})

